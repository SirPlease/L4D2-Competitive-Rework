/*
*	Spray Exploit Fixer
*	Copyright (C) 2021 Silvers
*
*	This program is free software: you can redistribute it and/or modify
*	it under the terms of the GNU General Public License as published by
*	the Free Software Foundation, either version 3 of the License, or
*	(at your option) any later version.
*
*	This program is distributed in the hope that it will be useful,
*	but WITHOUT ANY WARRANTY; without even the implied warranty of
*	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*	GNU General Public License for more details.
*
*	You should have received a copy of the GNU General Public License
*	along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/



#define PLUGIN_VERSION 		"2.3"

/*=======================================================================================
	Plugin Info:

*	Name	:	[ANY] Spray Exploit Fixer
*	Author	:	SilverShot
*	Descrp	:	Deletes bad sprays and prevents them from crashing clients.
*	Link	:	https://forums.alliedmods.net/showthread.php?t=323447
*	Plugins	:	https://sourcemod.net/plugins.php?exact=exact&sortby=title&search=1&author=Silvers

========================================================================================
	Change Log:

2.3 (12-Nov-2021)
	- Added a check for missing downloads folder and filename. Thanks to "nebsun" for reporting.
	- Changes to fix warnings when compiling on SourceMod 1.11.

2.2 (30-Jun-2021)
	- Fixed another Spray exploit. Thanks to "Madness (null138)" for fixing and reporting.

2.1 (31-Mar-2021)
	- Added a check for "sm_sprays_allowed" in the command admin_overrides.cfg to only allow specific flag groups to use sprays.

2.0 (09-Aug-2020)
	- Now should support all games.
	- Added more checks for invalid files.
	- Added cvar "spray_exploit_fixer_path" to specify the downloads folder if not correctly detected.
	- Removed gamedata and DHooks dependency.
	- Removed cvar "spray_exploit_fixer_name".

1.6 (15-Jul-2020)
	- Fixed issue with CSS game. Thanks to "NeonC" for reporting.
	- Added cvar "spray_exploit_fixer_name" to choose the method for retrieving the spray owner.

1.5 (14-May-2020)
	- Added better error log message when gamedata file is missing.
	- Fixed gamedata for HL2:DM. Thanks to "CliptonHeist" for reporting and "asherkin" for explaining engine != game.
	- (Info: the gamedata "engine" key for HL2:DM uses "hl2dm" (the engine name) while the "game" part uses "hl2mp" (game name) e.g. for offsets).

1.4 (10-May-2020)
	- Added support for "Zombie Panic! Source" game. Requires gamedata update.
	- Fixed "sm_spray_test" timing out when checking many sprays. Thanks to "Sreaper" for reporting and testing.
	- Now checks 50 files and waits 0.1 seconds before checking the next batch.
	- TF2 updated to fix clients crashing, but this plugin is still recommended to delete the other randomly uploaded user files.

1.3 (26-Apr-2020)
	- Changed cvar "spray_exploit_fixer_log" to log all files or only invalid sprays.
	- Logging now saves to "sourcemod/logs/spray_downloads.log" file.

1.2 (23-Apr-2020)
	- Added better checks to detect more bad sprays.
	- Added better checks for TF2 and other games to avoid false positives.
	- Prevented banning people in TF2 since many random invalid files are sent, not just sprays.

1.1 (21-Apr-2020)
	- Added better checks to prevent false positives.
	- Added ability to detect the users uploading sprays or other files.
	- Added cvar "spray_exploit_fixer_ban" to ban players with invalid sprays.
	- Added cvar "spray_exploit_fixer_log" to log players and files they uploaded.
	- Changed "sm_spray_test" to allow recursive searching the downloads directory.
	- Fixed plugin crashing TF2.
	- Updated GameData required.

1.0 (20-Apr-2020)
	- Initial release.

======================================================================================*/

#pragma semicolon 1
#pragma newdecls required

#include <sourcemod>
#include <sdktools>

#define CFG_BLOCKED		"data/spray_exploit_blocked.cfg"
#define CFG_CHECKED		"data/spray_exploit_checked.cfg"
#define MAX_READ		50

int g_iVal[] = {86,84,70,0,7,0,0,0,42,0,0,0,42,0,0,0,42,42,42,42,42,42,42,42,42,42,42,0};
char g_sFilename[PLATFORM_MAX_PATH];
char g_sDownloads[PLATFORM_MAX_PATH];
ConVar g_hCvarBan, g_hCvarLog, g_hCvarPath;
EngineVersion g_iEngine;
StringMap g_smChecked;
float g_fTime;
bool g_bDecal;

public Plugin myinfo =
{
	name = "[ANY] Spray Exploit Fixer",
	author = "SilverShot",
	description = "Deletes bad sprays and prevents them from crashing clients.",
	version = PLUGIN_VERSION,
	url = "https://forums.alliedmods.net/showthread.php?t=323447"
}

public APLRes AskPluginLoad2(Handle myself, bool late, char[] error, int err_max)
{
	g_iEngine = GetEngineVersion();

	return APLRes_Success;
}

public void OnPluginStart()
{
	RegAdminCmd("sm_spray_test", CmdSprays, ADMFLAG_ROOT, "Tests all sprays in the games downloads folder, listing bad ones.");

	switch( g_iEngine )
	{
		case Engine_SourceSDK2006, Engine_SourceSDK2007, Engine_Left4Dead, Engine_Left4Dead2:
		{
			Format(g_sDownloads, sizeof(g_sDownloads), "downloads/");
		}
		default:
		{
			Format(g_sDownloads, sizeof(g_sDownloads), "download/user_custom/cc/");
		}
	}

	CreateConVar(					"spray_exploit_fixer",			PLUGIN_VERSION,		"Spray Exploit Fixer plugin version.", FCVAR_DONTRECORD);
	if( g_iEngine != Engine_TF2 )
		g_hCvarBan = CreateConVar(	"spray_exploit_fixer_ban",		"0",				"0=Off. 1=Ban users who trigger invalid sprays (may still be some false positives).");
	g_hCvarLog = CreateConVar(		"spray_exploit_fixer_log",		"1",				"Logging saved to sourcemod/logs/spray_downloads.log: 0=Off. 1=Log all user uploads. 2=Log invalid sprays only.");
	g_hCvarPath = CreateConVar(		"spray_exploit_fixer_path",		g_sDownloads,		"Path to the downloads folder of sprays. Add /cc/ if sprays are stored in individual 2 character folders. Must contain trailing / slash.");
	AutoExecConfig(true,			"spray_exploit_fixer");
	g_hCvarPath.AddChangeHook(ConVarChanged_Cvars);

	char sPath[PLATFORM_MAX_PATH];
	File hFile;
	g_smChecked = new StringMap();

	BuildPath(Path_SM, sPath, sizeof(sPath), CFG_BLOCKED);
	if( FileExists(sPath) )
	{
		hFile = OpenFile(sPath, "r");
		if( hFile )
		{
			while( !hFile.EndOfFile() && hFile.ReadLine(sPath, sizeof(sPath)) && sPath[0] )
			{
				sPath[strlen(sPath)-1] = 0; // Remove newline
				if( sPath[0] )
				{
					g_smChecked.SetValue(sPath, false);
				}
			}
			delete hFile;
		}
	}

	BuildPath(Path_SM, sPath, sizeof(sPath), CFG_CHECKED);
	if( FileExists(sPath) )
	{
		hFile = OpenFile(sPath, "r");
		if( hFile )
		{
			while( !hFile.EndOfFile() && hFile.ReadLine(sPath, sizeof(sPath)) && sPath[0] )
			{
				sPath[strlen(sPath)-1] = 0; // Remove newline
				if( sPath[0] )
				{
					g_smChecked.SetValue(sPath, true);
				}
			}
			delete hFile;
		}
	}

	AddTempEntHook("Player Decal", PlayerDecal);
}

public void ConVarChanged_Cvars(Handle convar, const char[] oldValue, const char[] newValue)
{
	g_hCvarPath.GetString(g_sDownloads, sizeof(g_sDownloads));
}

public Action CmdSprays(int client, int a)
{
	int count, counts;

	g_fTime = GetEngineTime();
	int pos = StrContains(g_sDownloads, "/");
	if( pos != -1 ) g_sDownloads[pos] = 0;
	RecursiveSearchDirs(client, g_sDownloads, count, counts, 0, null);
	if( pos != -1 ) g_sDownloads[pos] = '/';

	return Plugin_Handled;
}

void RecursiveSearchDirs(int client, const char[] sDir, int &count, int &counts, int level, DirectoryListing hDir)
{
	char sPath[PLATFORM_MAX_PATH];
	FileType type;
	File hFile;
	int iRead[sizeof(g_iVal)];
	int total;
	level++;

	if( hDir == null && DirExists(sDir) )
		hDir = OpenDirectory(sDir, true);

	if( hDir )
	{
		while( hDir.GetNext(sPath, sizeof(sPath), type) )
		{
			if( strcmp(sPath, ".") && strcmp(sPath, "..") )
			{
				if( type == FileType_Directory )
				{
					Format(sPath, sizeof(sPath), "%s/%s", sDir, sPath);
					RecursiveSearchDirs(client, sPath, count, counts, level, null);
				}
				else if( type == FileType_File )
				{
					int len = strlen(sPath);
					if( len > 4 && strcmp(sPath[len - 4], ".dat") == 0 )
					{
						counts++;
						Format(sPath, sizeof(sPath), "%s/%s", sDir, sPath);

						hFile = OpenFile(sPath, "rb");
						hFile.Read(iRead, sizeof(iRead), 1);
						delete hFile;

						int i = ValFile(iRead);
						if( i != -1 )
						{
							count++;
							PrintToServer("Invalid file: %s: %02d (%02X <> %02X)", sPath, i, iRead[i], g_iVal[i]);
						}
					}
				}

				if( total++ > MAX_READ )
				{
					level--;
					DataPack dPack;
					CreateDataTimer(0.1, TimerNext, dPack);
					dPack.WriteCell(client);
					dPack.WriteString(sDir);
					dPack.WriteCell(count);
					dPack.WriteCell(counts);
					dPack.WriteCell(level);
					dPack.WriteCell(hDir);
					return;
				}
			}
		}
	}

	delete hDir;
	level--;

	if( level == 0 )
		ReplyToCommand(client, "Sprays checked. Found %d of %d invalid. Took %0.2f seconds.", count, counts, GetEngineTime() - g_fTime);
}

public Action TimerNext(Handle timer, DataPack dPack)
{
	DirectoryListing hDir;
	char sDir[PLATFORM_MAX_PATH];
	int client, count, counts, level;

	dPack.Reset();
	client = dPack.ReadCell();
	dPack.ReadString(sDir, sizeof(sDir));
	count = dPack.ReadCell();
	counts = dPack.ReadCell();
	level = dPack.ReadCell();
	hDir = dPack.ReadCell();

	RecursiveSearchDirs(client, sDir, count, counts, level, hDir);

	return Plugin_Continue;
}

public Action PlayerDecal(const char[] te_name, const int[] Players, int numClients, float delay)
{
	if( g_bDecal ) return Plugin_Continue;

	int client = TE_ReadNum("m_nPlayer");
	if( !client || !IsClientInGame(client) || !CheckCommandAccess(client, "sm_sprays_allowed", 0, true) )
	{
		return Plugin_Handled;
	}

	GetPlayerDecalFile(client, g_sFilename, sizeof(g_sFilename));

	bool val;
	if( g_sFilename[0] )
	{
		char cc[6];
		Format(cc, sizeof(cc), "/%c%c/", g_sFilename[0], g_sFilename[1]);
		Format(g_sFilename, sizeof(g_sFilename), "%s%s.dat", g_sDownloads, g_sFilename);
		ReplaceString(g_sFilename, sizeof(g_sFilename), "/cc/", cc);

		if( !g_smChecked.GetValue(g_sFilename, val) )
		{
			FileCheck();

			g_smChecked.GetValue(g_sFilename, val);
		}
	}

	if( !val )
	{
		char auth[20];
		GetClientAuthId(client, AuthId_Steam2, auth, sizeof(auth));

		if( FileExists(g_sFilename) )
		{
			if( g_hCvarLog.IntValue ) LogCustom("Blocked invalid spray: %s from (%N) [%s]", g_sFilename, client, auth);
			PrintToServer("Blocked invalid spray: %s from (%N) [%s]", g_sFilename, client, auth);
		}
		else
		{
			if( g_hCvarLog.IntValue ) LogCustom("Blocked unchecked spray - missing file: %s from (%N) [%s]", g_sFilename, client, auth);
			PrintToServer("Blocked unchecked spray - missing file: %s from (%N) [%s]", g_sFilename, client, auth);
		}

		float vPos[3];
		TE_ReadVector("m_vecOrigin", vPos);
		DataPack hPack = new DataPack();
		hPack.WriteCell(GetClientUserId(client));
		hPack.WriteFloat(vPos[0]);
		hPack.WriteFloat(vPos[1]);
		hPack.WriteFloat(vPos[2]);
		RequestFrame(ReqTempEnt, hPack);
		return Plugin_Handled;
	}

	return Plugin_Continue;
}

public void ReqTempEnt(DataPack hPack)
{
	hPack.Reset();

	int client = hPack.ReadCell();
	client = GetClientOfUserId(client);
	if( client )
	{
		float vPos[3];
		vPos[0] = hPack.ReadFloat();
		vPos[1] = hPack.ReadFloat();
		vPos[2] = hPack.ReadFloat();

		g_bDecal = true;
		TE_Start("Player Decal");
		TE_WriteVector("m_vecOrigin", vPos);
		TE_WriteNum("m_nEntity", 0);
		TE_WriteNum("m_nPlayer", client);
		TE_SendToClient(client);
		g_bDecal = false;
	}
	delete hPack;
}

int GetClientFromSpray()
{
	char hex[10];
	for( int i = 1; i <= MaxClients; i++ )
	{
		if( IsClientInGame(i) )
		{
			hex[0] = 0;
			GetPlayerDecalFile(i, hex, sizeof(hex));
			if( hex[0] && StrContains(g_sFilename, hex) != -1 )
				return i;
		}
	}

	return 0;
}

int GetClientFromJingle()
{
	char hex[10];
	for( int i = 1; i <= MaxClients; i++ )
	{
		if( IsClientInGame(i) )
		{
			hex[0] = 0;
			GetPlayerJingleFile(i, hex, sizeof(hex));
			if( hex[0] && StrContains(g_sFilename, hex) != -1 )
				return i;
		}
	}

	return 0;
}

public Action OnFileReceive(int client, const char[] sFile)
{
	strcopy(g_sFilename, sizeof(g_sFilename), sFile);

	if( g_hCvarLog.IntValue == 1 )
	{
		client = GetClientFromSpray();
		if( !client ) client = GetClientFromJingle();
		if( client )
		{
			char auth[20];
			GetClientAuthId(client, AuthId_Steam2, auth, sizeof(auth));
			LogCustom("File received: %s from (%N) [%s]", sFile, client, auth);

		}
		else
		{
			LogCustom("File received: %s", sFile);
		}
	}

	bool val;
	if( g_smChecked.GetValue(sFile, val) )
	{
		g_smChecked.Remove(sFile);
	}

	return Plugin_Continue;
}

public Action OnFileSend(int client, const char[] sFile)
{
	strcopy(g_sFilename, sizeof(g_sFilename), sFile);

	bool val;
	if( g_smChecked.GetValue(sFile, val) )
	{
		if( !val ) return Plugin_Handled;
	} else {
		FileCheck();

		if( g_smChecked.GetValue(sFile, val) )
		{
			if( !val ) return Plugin_Handled;
		}
	}
	return Plugin_Continue;
}

void FileCheck()
{
	if( FileExists(g_sFilename) )
	{
		int len = strlen(g_sFilename);
		if( len > 4 && strcmp(g_sFilename[len - 4], ".dat") == 0 )
		{
			int iRead[sizeof(g_iVal)];
			File hFile = OpenFile(g_sFilename, "rb", false);
			hFile.Read(iRead, sizeof(iRead), 1);
			delete hFile;

			int i = ValFile(iRead);

			if( i != -1 )
			{
				int client = GetClientFromSpray();
				if( !client ) client = GetClientFromJingle();
				if( client )
				{
					char auth[20];
					GetClientAuthId(client, AuthId_Steam2, auth, sizeof(auth));
					if( g_hCvarLog.IntValue ) LogCustom("Invalid spray: %s from (%N) [%s]", g_sFilename, client, auth);
					PrintToServer("Invalid spray: %s: %02d (%02X <> %02X) from (%N) [%s]", g_sFilename, i, iRead[i], g_iVal[i], client, auth);
				} else {
					if( g_hCvarLog.IntValue ) LogCustom("Invalid spray: %s", g_sFilename);
					PrintToServer("Invalid spray: %s: %02d (%02X <> %02X)", g_sFilename, i, iRead[i], g_iVal[i]);
				}

				if( g_iEngine != Engine_TF2 )
				{
					if( client && g_hCvarBan.IntValue )
					{
						BanClient(client, 0, BANFLAG_AUTO, "Banned");
					}
				}

				ConfigFile(false);
				return;
			}

			ConfigFile(true);
		}
	}
}

void ConfigFile(bool test)
{
	g_smChecked.SetValue(g_sFilename, test);

	char sPath[PLATFORM_MAX_PATH];
	BuildPath(Path_SM, sPath, sizeof(sPath), test ? CFG_CHECKED : CFG_BLOCKED);
	File hFile = OpenFile(sPath, "w+");
	if( hFile )
	{
		hFile.WriteLine(g_sFilename);
		delete hFile;
	}
}

int ValFile(int iRead[sizeof(g_iVal)])
{
	char bytes[10];
	bool read = true;
	int n;

	for( int i = 0; i < sizeof(g_iVal); i++ )
	{
		if( i == 0 && g_iEngine == Engine_TF2 && iRead[i] == 82 && iRead[i+1] == 73 && iRead[i+2] == 70 && iRead[i+3] == 70 && iRead[i+8] == 87 && iRead[i+9] == 65 && iRead[i+10] == 86 && iRead[i+11] == 69 && iRead[i+12] == 102 && iRead[i+13] == 109 && iRead[i+14] == 116 )
		{
			break;
		}
		else if( g_iVal[i] == 42 )
		{
			switch( i )
			{
				case 8:	read = iRead[i] <= 5;
				case 16, 18:
				{
					Format(bytes, sizeof(bytes), "%02X%02X", iRead[i+1], iRead[i]);
					n = HexToDec(bytes);
					if( n < 0 || n > 8192 ) read = false;
				}
				case 20:
				{
					Format(bytes, sizeof(bytes), "%02X%02X%02X%02X", iRead[i+3], iRead[i+2], iRead[i+1], iRead[i]);
					n = HexToDec(bytes);
					if( n & (0x8000|0x10000|0x800000) ) read = false;
				}
				case 25:
				{
					if( iRead[i] > 0 ) read = false;
				}
			}
		} else {
			read = iRead[i] == g_iVal[i];
		}

		if( !read ) return i;
	}

	return -1;
}

int HexToDec(char[] bytes)
{
	int len = strlen(bytes);
	int base = 1;
	int value = 0;

	for( int i = len - 1; i >= 0; i-- )
	{
		if( bytes[i] >= '0' && bytes[i] <= '9' )
		{
			value += (bytes[i] - 48) * base;
			base = base * 16;
		}

		else if( bytes[i] >= 'A' && bytes[i] <= 'F' )
		{
			value += (bytes[i] - 55) * base;
			base = base * 16;
		}
	}

	return value;
}

void LogCustom(const char[] format, any ...)
{
	char buffer[512];
	VFormat(buffer, sizeof(buffer), format, 2);

	char sPath[PLATFORM_MAX_PATH], sTime[32];
	BuildPath(Path_SM, sPath, sizeof(sPath), "logs/spray_downloads.log");
	File file = OpenFile(sPath, "a+");
	FormatTime(sTime, sizeof(sTime), "%d-%b-%Y - %H:%M:%S");
	file.WriteLine("%s: %s", sTime, buffer);
	FlushFile(file);
	delete file;
}