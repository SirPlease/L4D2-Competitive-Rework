"Games"
{
	/*
	 * Many signatures were found or updated by "Silvers".
	 * Many detours were created by "Silvers".
	 * Some signatures and detours were created by "Psyk0tik" from: https://github.com/Psykotikism/L4D1-2_Signatures
	 * Please credit when using them.
	 */
	"left4dead2"
	{
		// ====================================================================================================
		// DETOURS
		// ====================================================================================================
		"Functions"
		{
			"L4DD::CTankClaw::DoSwing"
			{
				"signature"		"CTankClaw::DoSwing"
				"callconv"		"thiscall"
				"return"		"void"
				"this"			"entity"
			}

			"L4DD::CTankClaw::GroundPound"
			{
				"signature"		"CTankClaw::GroundPound"
				"callconv"		"thiscall"
				"return"		"void"
				"this"			"entity"
			}

			"L4DD::CTankClaw::OnPlayerHit"
			{
				"signature"		"CTankClaw::OnPlayerHit"
				"callconv"		"thiscall"
				"return"		"void"
				"this"			"entity"
				"arguments"
				{
					"player"
					{
						"type"		"cbaseentity"
					}
					"incap"
					{
						"type"		"bool"
					}
				}
			}

			"L4DD::CTankRock::Detonate"
			{
				"signature"		"CTankRock::Detonate"
				"callconv"		"thiscall"
				"return"		"void"
				"this"			"entity"
			}

			"L4DD::CTankRock::OnRelease"
			{
				"signature"		"CTankRock::OnRelease"
				"linux"
				{
					"callconv"	"cdecl"
				}
				"windows"
				{
					"callconv"	"stdcall"
				}
				"return"		"void"
				"this"			"ignore"
				"arguments"
				{
					"pThis"
					{
						"type"		"cbaseentity"
						"windows"
						{
							"register"	"ecx"
						}
					}
					"vec"
					{
						"type"		"vectorptr"
					}
					"ang"
					{
						"type"		"vectorptr"
					}
					"vec2"
					{
						"type"		"vectorptr"
					}
					"vec3"
					{
						"type"		"vectorptr"
					}
				}
			}

			"L4DD::CDeathFallCamera::Enable"
			{
				"signature"		"CDeathFallCamera::Enable"
				"callconv"		"thiscall"
				"return"		"void"
				"this"			"entity"
				"arguments"
				{
					"player"
					{
						"type"		"cbaseentity"
					}
				}
			}

			"L4DD::CTerrorPlayer::Cough"
			{
				"signature"		"CTerrorPlayer::Cough"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
				"arguments"
				{
					"player"
					{
						"type"		"cbaseentity"
					}
				}
			}

			"L4DD::CTerrorPlayer::OnKnockedDown"
			{
				"signature"		"CTerrorPlayer::OnKnockedDown"
				"callconv"		"thiscall"
				"return"		"void"
				"this"			"entity"
				"arguments"
				{
					"something"
					{
						"type"		"int"
					}
				}
			}

			"L4DD::CTerrorPlayer::OnSlammedSurvivor"
			{
				"signature"		"CTerrorPlayer::OnSlammedSurvivor"
				"callconv"		"thiscall"
				"return"		"void"
				"this"			"entity"
				"arguments"
				{
					"pVictim"
					{
						"type"	"cbaseentity"
					}
					"bWallSlam"
					{
						"type"	"bool"
					}
					"bDeadlyCharge"
					{
						"type"	"bool"
					}
				}
			}

			"L4DD::CTerrorPlayer::QueuePummelVictim"
			{
				"signature"		"CTerrorPlayer::QueuePummelVictim"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
				"arguments"
				{
					"attacker"
					{
						"type"		"cbaseentity"
					}
					"something"
					{
						"type"		"float"
					}
				}
			}

			"L4DD::ThrowImpactedSurvivor"
			{
				"signature"		"ThrowImpactedSurvivor"
				"callconv"		"cdecl"
				"return"		"int"
				"this"			"ignore"
				"arguments"
				{
					"attacker"
					{
						"type"		"cbaseentity"
					}
					"victim"
					{
						"type"		"cbaseentity"
					}
					"something"
					{
						"type"		"float"
					}
					"damage"
					{
						"type"		"bool"
					}
				}
			}

			"L4DD::CTerrorPlayer::CancelStagger"
			{
				"signature"		"CTerrorPlayer::CancelStagger"
				"callconv"		"thiscall"
				"return"		"void"
				"this"			"entity"
			}

			"L4DD::CTerrorPlayer::IsMotionControlledXY"
			{
				"signature"		"CTerrorPlayer::IsMotionControlledXY"
				"callconv"		"thiscall"
				"return"		"bool"
				"this"			"entity"
				"arguments"
				{
					"activity"
					{
						"type"		"int"
					}
				}
			}

			"L4DD::CTerrorPlayer::Fling"
			{
				"signature"		"CTerrorPlayer::Fling"
				"callconv"		"thiscall"
				"return"		"void"
				"this"			"entity"
				"arguments"
				{
					"velocity"
					{
						"type"		"vectorptr"
					}
					"animation"
					{
						"type"		"int"
					}
					"charger"
					{
						"type"		"cbaseentity"
					}
					"viewDuration"
					{
						"type"		"float"
					}
				}
			}

			"L4DD::CTerrorPlayer::OnFalling"
			{
				"signature"		"CTerrorPlayer::OnFalling"
				"callconv"		"thiscall"
				"return"		"void"
				"this"			"entity"
			}

			"L4DD::Witch::SetHarasser"
			{
				"signature"		"Witch::SetHarasser"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
				"arguments"
				{
					"victim"
					{
						"type"		"cbaseentity"
					}
				}
			}

			"L4DD::Tank::EnterStasis"
			{
				"signature"		"Tank::EnterStasis"
				"callconv"		"thiscall"
				"return"		"void"
				"this"			"entity"
			}

			"L4DD::Tank::LeaveStasis"
			{
				"signature"		"Tank::LeaveStasis"
				"callconv"		"thiscall"
				"return"		"void"
				"this"			"entity"
			}

			"L4DD::ZombieManager::GetRandomPZSpawnPosition"
			{
				"signature"		"ZombieManager::GetRandomPZSpawnPosition"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
				"arguments"
				{
					"zombieClass"
					{
						"type"	"int"
					}
					"attempts"
					{
						"type"	"int"
					}
					"client"
					{
						"type"	"cbaseentity"
					}
					"vecPos"
					{
						"type"	"int"
					}
				}
			}

			"L4DD::ZombieManager::SpawnSpecial"
			{
				"signature"		"ZombieManager::SpawnSpecial"
				"callconv"		"thiscall"
				"return"		"cbaseentity"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"int"
					}
					"a2"
					{
						"type"	"vectorptr"
					}
					"a3"
					{
						"type"	"vectorptr"
					}
				}
			}

			"L4DD::ZombieManager::SpawnSpecial_Clone"
			{
				"signature"		"ZombieManager::SpawnSpecial_Clone"
				"callconv"		"thiscall"
				"return"		"cbaseentity"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"int"
					}
					"a2"
					{
						"type"	"int"
					}
					"a3"
					{
						"type"	"vectorptr"
					}
				}
			}

			"L4DD::ZombieManager::SpawnTank"
			{
				"signature"		"ZombieManager::SpawnTank"
				"callconv"		"thiscall"
				"return"		"cbaseentity"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"vectorptr"
					}
					"a2"
					{
						"type"	"vectorptr"
					}
				}
			}

			"L4DD::ZombieManager::SpawnWitch"
			{
				"signature"		"ZombieManager::SpawnWitch"
				"callconv"		"thiscall"
				"return"		"cbaseentity"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"vectorptr"
					}
					"a2"
					{
						"type"	"vectorptr"
					}
				}
			}

			"L4DD::ZombieManager::SpawnWitchBride"
			{
				"signature"		"ZombieManager::SpawnWitchBride"
				"callconv"		"thiscall"
				"return"		"cbaseentity"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"vectorptr"
					}
					"a2"
					{
						"type"	"vectorptr"
					}
				}
			}

			"L4DD::CDirector::OnMobRushStart"
			{
				"signature"		"CDirector::OnMobRushStart"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
			}

			"L4DD::ZombieManager::SpawnITMob"
			{
				"signature"		"ZombieManager::SpawnITMob"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"int"
					}
				}
			}

			"L4DD::ZombieManager::SpawnMob"
			{
				"signature"		"ZombieManager::SpawnMob"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"int"
					}
				}
			}

			"L4DD::CTerrorPlayer::OnEnterGhostState"
			{
				"signature"		"CTerrorPlayer::OnEnterGhostState"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
			}

			"L4DD::CTerrorPlayer::TakeOverBot"
			{
				"signature"		"CTerrorPlayer::TakeOverBot"
				"callconv"		"thiscall"
				"return"		"bool"
				"this"			"entity"
				"arguments"
				{
					"a1"
					{
						"type"	"bool"
					}
				}
			}

			"L4DD::CDirector::IsTeamFull"
			{
				"signature"		"CDirector::IsTeamFull"
				"callconv"		"thiscall"
				"return"		"bool"
				"arguments"
				{
					"a1"
					{
						"type"	"int"
					}
					"a2"
					{
						"type"	"int"
					}
				}
			}

			"L4DD::CTerrorGameRules::ClearTeamScores"
			{
				"signature"		"CTerrorGameRules::ClearTeamScores"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"bool"
					}
				}
			}

			"L4DD::CTerrorGameRules::SetCampaignScores"
			{
				"signature"		"CTerrorGameRules::SetCampaignScores"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"int"
					}
					"a2"
					{
						"type"	"int"
					}
				}
			}

			"L4DD::CDirector::OnFirstSurvivorLeftSafeArea"
			{
				"signature"		"CDirector::OnFirstSurvivorLeftSafeArea"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"cbaseentity"
					}
				}
			}

			"L4DD::CDirector::OnForceSurvivorPositions"
			{
				"signature"		"CDirector::OnForceSurvivorPositions"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"objectptr"
					}
				}
			}

			"L4DD::CDirector::OnReleaseSurvivorPositions"
			{
				"signature"		"CDirector::OnReleaseSurvivorPositions"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"objectptr"
					}
				}
			}

			"L4DD::SpeakResponseConceptFromEntityIO"
			{
				"signature"		"SpeakResponseConceptFromEntityIO"
				"callconv"		"cdecl"
				"return"		"int"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"cbaseentity"
					}
					"a2"
					{
						"type"	"int"
					}
					"a3"
					{
						"type"	"objectptr"
					}
				}
			}

			"L4DD::CTerrorPlayer::GetCrouchTopSpeed"
			{
				"signature"		"CTerrorPlayer::GetCrouchTopSpeed"
				"callconv"		"thiscall"
				"return"		"float"
				"this"			"entity"
			}

			"L4DD::CTerrorPlayer::GetRunTopSpeed"
			{
				"signature"		"CTerrorPlayer::GetRunTopSpeed"
				"callconv"		"thiscall"
				"return"		"float"
				"this"			"entity"
			}

			"L4DD::CTerrorPlayer::GetWalkTopSpeed"
			{
				"signature"		"CTerrorPlayer::GetWalkTopSpeed"
				"callconv"		"thiscall"
				"return"		"float"
				"this"			"entity"
			}

			"L4DD::CDirector::GetScriptValueInt"
			{
				"signature"		"CDirector::GetScriptValueInt"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"charptr"
					}
					"a2"
					{
						"type"	"int"
					}
				}
			}

			"L4DD::CDirector::GetScriptValueFloat"
			{
				"signature"		"CDirector::GetScriptValueFloat"
				"callconv"		"thiscall"
				"return"		"float"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"charptr"
					}
					"a2"
					{
						"type"	"float"
					}
				}
			}

			"L4DD::CDirector::GetScriptValueVector"
			{
				"signature"		"CDirector::GetScriptValueVector"
				"callconv"		"thiscall"
				"return"		"vectorptr"
				"this"			"ignore"
				"arguments"
				{
					"ret"
					{
						"type"	"vectorptr"
					}
					"a2"
					{
						"type"	"charptr"
					}
					"a3"
					{
						"type"	"float"
					}
					"a4"
					{
						"type"	"float"
					}
					"a5"
					{
						"type"	"float"
					}
				}
			}

			"L4DD::CDirector::GetScriptValueString"
			{
				"signature"		"CDirector::GetScriptValueString"
				"callconv"		"thiscall"
				"return"		"charptr"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"charptr"
					}
					"a2"
					{
						"type"	"charptr"
					}
					"a3"
					{
						"type"	"charptr"
					}
					"a4"
					{
						"type"	"int"
					}
				}
			}

			"CSquirrelVM::GetValue"
			{
				"offset"		"CSquirrelVM::GetValue"
				"hooktype"		"raw"
				"return"		"bool"
				"this"			"ignore"
				"arguments"
				{
					"hScope"
					{
						"type"	"int"
					}
					"pszKey"
					{
						"type"	"charptr"
					}
					"pValue"
					{
						"type"	"objectptr"
					}
				}
			}

			"L4DD::CTerrorGameRules::HasConfigurableDifficultySetting"
			{
				"signature"		"CTerrorGameRules::HasConfigurableDifficultySetting"
				"callconv"		"thiscall"
				"return"		"bool"
				"this"			"ignore"
			}

			"L4DD::CTerrorGameRules::GetSurvivorSet"
			{
				"signature"		"CTerrorGameRules::GetSurvivorSet"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
			}

			"L4DD::CTerrorGameRules::FastGetSurvivorSet"
			{
				"signature"		"CTerrorGameRules::FastGetSurvivorSet"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
			}

			"L4DD::CDirectorVersusMode::GetMissionVersusBossSpawning"
			{
				"signature"		"CDirectorVersusMode::GetMissionVersusBossSpawning"
				"callconv"		"thiscall"
				"return"		"bool"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"objectptr"
					}
					"a2"
					{
						"type"	"objectptr"
					}
					"a3"
					{
						"type"	"objectptr"
					}
					"a4"
					{
						"type"	"objectptr"
					}
					"a5"
					{
						"type"	"objectptr"
					}
				}
			}

			"L4DD::ZombieManager::ReplaceTank"
			{
				"signature"		"ZombieManager::ReplaceTank"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"cbaseentity"
					}
					"a2"
					{
						"type"	"cbaseentity"
					}
				}
			}

			"L4DD::CDirector::TryOfferingTankBot"
			{
				"signature"		"CDirector::TryOfferingTankBot"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"cbaseentity"
					}
					"a2"
					{
						"type"	"bool"
					}
				}
			}

			"L4DD::CThrow::ActivateAbililty"
			{
				"signature"		"CThrow::ActivateAbililty"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
			}

			"L4DD::CBaseAnimating::SelectWeightedSequence"
			{
				"signature"		"CBaseAnimating::SelectWeightedSequence"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
				"arguments"
				{
					"a1"
					{
						"type"	"int"
					}
				}
			}

			"L4DD::CTerrorPlayer::DoAnimationEvent"
			{
				"signature"		"CTerrorPlayer::DoAnimationEvent"
				"callconv"		"thiscall"
				"return"		"void"
				"this"			"entity"
				"arguments"
				{
					"event"
					{
						"type"	"int"
					}
					"variant"
					{
						"type"	"int"
					}
				}
			}

			"L4DD::CTerrorMeleeWeapon::GetDamageForVictim"
			{
				"signature"		"CTerrorMeleeWeapon::GetDamageForVictim"
				"callconv"		"thiscall"
				"return"		"float"
				"this"			"entity"
				"arguments"
				{
					"victim"
					{
						"type" "cbaseentity"
					}
				}
			}

			"L4DD::CTerrorMeleeWeapon::StartMeleeSwing"
			{
				"signature"		"CTerrorMeleeWeapon::StartMeleeSwing"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"cbaseentity"
					}
					"a2"
					{
						"type"	"bool"
					}
				}
			}

			/* Works for Linux L4D2 but not L4D1, currently leaving out
			"L4DD::CDirectorScriptedEventManager::SendInRescueVehicle"
			{
				"signature"		"CDirectorScriptedEventManager::SendInRescueVehicle"
				"callconv"		"cdecl"
				"return"		"void"
				"arguments"
				{
					"ret"
					{
						"type"	"object"
						"size"	"2"
					}
					"this"
					{
						"type"	"cbaseentity"
						"windows"
						{
							"register"	"ecx"
						}
					}
				}
			}
			*/
			"L4DD::CDirectorScriptedEventManager::SendInRescueVehicle"
			{
				"signature"		"CDirectorScriptedEventManager::SendInRescueVehicle"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
			}

			"L4DD::CDirectorScriptedEventManager::ChangeFinaleStage"
			{
				"signature"		"CDirectorScriptedEventManager::ChangeFinaleStage"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"int"
					}
					"a2"
					{
						"type"	"charptr"
					}
				}
			}

			"L4DD::CDirectorVersusMode::EndVersusModeRound"
			{
				"signature"		"CDirectorVersusMode::EndVersusModeRound"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"bool"
					}
				}
			}

			"L4DD::CTerrorPlayer::OnLedgeGrabbed"
			{
				"signature"		"CTerrorPlayer::OnLedgeGrabbed"
				"callconv"		"thiscall"
				"return"		"void"
				"this"			"entity"
				"arguments"
				{
					"a1"
					{
						"type"	"vectorptr"
					}
				}
			}

			"L4DD::CTerrorPlayer::OnRevived"
			{
				"signature"		"CTerrorPlayer::OnRevived"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
			}

			"L4DD::CTerrorPlayer::OnStaggered"
			{
				"signature"		"CTerrorPlayer::OnStaggered"
				"callconv"		"thiscall"
				"return"		"void"
				"this"			"entity"
				"arguments"
				{
					"a1"
					{
						"type"	"cbaseentity"
					}
					"a2"
					{
						"type"	"vectorptr"
					}
				}
			}

			"L4DD::CTerrorWeapon::OnSwingStart"
			{
				"signature"		"CTerrorWeapon::OnSwingStart"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
			}

			"L4DD::CTerrorPlayer::OnShovedBySurvivor"
			{
				"signature"		"CTerrorPlayer::OnShovedBySurvivor"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
				"arguments"
				{
					"a1"
					{
						"type"	"cbaseentity"
					}
					"a2"
					{
						"type"	"vectorptr"
					}
				}
			}

			"L4DD::CTerrorWeapon::OnHit"
			{
				"signature"		"CTerrorWeapon::OnHit"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
				"arguments"
				{
					"a1"
					{
						"type"	"objectptr"
					}
					"a2"
					{
						"type"	"vectorptr"
					}
					"a3"
					{
						"type"	"bool"
					}
				}
			}

			"L4DD::CTerrorPlayer::OnShovedByPounceLanding"
			{
				"signature"		"CTerrorPlayer::OnShovedByPounceLanding"
				"callconv"		"thiscall"
				"return"		"float"
				"this"			"entity"
				"arguments"
				{
					"a1"
					{
						"type"	"cbaseentity"
					}
					"a2"
					{
						"type"	"int"
					}
				}
			}

			"L4DD::CInferno::Spread"
			{
				"signature"		"CInferno::Spread"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
				"arguments"
				{
					"a1"
					{
						"type"	"vectorptr"
					}
				}
			}

			"L4DD::CPipeBombProjectile::Create"
			{
				"signature"		"CPipeBombProjectile::Create"
				"callconv"		"cdecl"
				"return"		"cbaseentity"
				"arguments"
				{
					"origin"
					{
						"type"		"vectorptr"
					}
					"angles"
					{
						"type"		"vectorptr"
					}
					"velocity"
					{
						"type"		"vectorptr"
					}
					"rotation"
					{
						"type"		"vectorptr"
					}
					"owner"
					{
						"type"		"cbaseentity"
					}
					"duration"
					{
						"type"		"float"
					}
				}
			}

			"L4DD::CPipeBombProjectile::Detonate"
			{
				"signature"		"CPipeBombProjectile::Detonate"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
			}

			"L4DD::CMolotovProjectile::Detonate"
			{
				"signature"		"CMolotovProjectile::Detonate"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
			}

			"L4DD::CVomitJarProjectile::Detonate"
			{
				"signature"		"CVomitJarProjectile::Detonate"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
			}

			"L4DD::CTerrorPlayer::Extinguish"
			{
				"signature"		"CTerrorPlayer::Extinguish"
				"callconv"		"thiscall"
				"return"		"void"
				"this"			"entity"
			}

			"L4DD::CTerrorPlayer::OnPouncedOnSurvivor"
			{
				"signature"		"CTerrorPlayer::OnPouncedOnSurvivor"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
				"arguments"
				{
					"a1"
					{
						"type"	"cbaseentity"
					}
				}
			}

			"L4DD::CTerrorPlayer::GrabVictimWithTongue"
			{
				"signature"		"CTerrorPlayer::GrabVictimWithTongue"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
				"arguments"
				{
					"a1"
					{
						"type"	"cbaseentity"
					}
				}
			}

			"L4DD::CTerrorPlayer::OnLeptOnSurvivor"
			{
				"signature"		"CTerrorPlayer::OnLeptOnSurvivor"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
				"arguments"
				{
					"a1"
					{
						"type"	"cbaseentity"
					}
				}
			}

			"L4DD::CTerrorPlayer::OnStartCarryingVictim"
			{
				"signature"		"CTerrorPlayer::OnStartCarryingVictim"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
				"arguments"
				{
					"a1"
					{
						"type"	"cbaseentity"
					}
				}
			}

			"L4DD::CCharge::ImpactStagger"
			{
				"signature"		"CCharge::ImpactStagger"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
			}

			"L4DD::CTerrorPlayer::OnVomitedUpon"
			{
				"signature"		"CTerrorPlayer::OnVomitedUpon"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
				"arguments"
				{
					"a1"
					{
						"type"	"cbaseentity"
					}
					"a2"
					{
						"type"	"bool"
					}
				}
			}

			"L4DD::CTerrorPlayer::OnHitByVomitJar"
			{
				"signature"		"CTerrorPlayer::OnHitByVomitJar"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
				"arguments"
				{
					"a1"
					{
						"type"	"cbaseentity"
					}
				}
			}

			"L4DD::CTerrorPlayer::MaterializeFromGhost"
			{
				"signature"		"CTerrorPlayer::MaterializeFromGhost"
				"callconv"		"thiscall"
				"return"		"void"
				"this"			"entity"
			}

			"L4DD::SurvivorBot::UseHealingItems"
			{
				"signature"		"SurvivorBot::UseHealingItems"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
				"arguments"
				{
					"a1"
					{
						"type"	"int"
					}
					"a2"
					{
						"type"	"int"
					}
				}
			}

			"L4DD::SurvivorBot::FindScavengeItem"
			{
				"signature"		"SurvivorBot::FindScavengeItem"
				"callconv"		"thiscall"
				"return"		"cbaseentity"
				"this"			"entity"
				"arguments"
				{
					"a1"
					{
						"type"	"float"
					}
				}
			}

			"L4DD::BossZombiePlayerBot::ChooseVictim"
			{
				"signature"		"BossZombiePlayerBot::ChooseVictim"
				"callconv"		"thiscall"
				"return"		"cbaseentity"
				"this"			"entity"
				"arguments"
				{
					"player"
					{
						"type"	"int"
					}
					"a_char"
					{
						"type"	"int"
					}
					"character"
					{
						"type"	"int"
					}
				}
			}

			"L4DD::CInsectSwarm::CanHarm"
			{
				"signature"		"CInsectSwarm::CanHarm"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
				"arguments"
				{
					"CBaseEntity"
					{
						"type"	"cbaseentity"
					}
				}
			}

			"L4DD::CBreakableProp::Break"
			{
				"signature"		"CBreakableProp::Break"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
				"arguments"
				{
					"entity"
					{
						"type"	"cbaseentity"
					}
					"a3"
					{
						"type"	"int"
					}
				}
			}

			"L4DD::CGasCan::Event_Killed"
			{
				"signature"		"CGasCan::Event_Killed"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
				"arguments"
				{
					"entity"
					{
						"type"	"objectptr"
					}
				}
			}

			"L4DD::CGasCan::ShouldStartAction"
			{
				"signature"		"CGasCan::ShouldStartAction"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"int"
					}
					"client"
					{
						"type"	"cbaseentity"
					}
					"nozzle"
					{
						"type"	"cbaseentity"
					}
				}
			}

			"L4DD::CGasCan::OnActionComplete"
			{
				"signature"		"CGasCan::OnActionComplete"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
				"arguments"
				{
					"client"
					{
						"type"	"cbaseentity"
					}
					"entity"
					{
						"type"	"cbaseentity"
					}
				}
			}

			/**
			 * Thanks to "Psyk0tik" from: https://github.com/Psykotikism/Mutant_Tanks
			 * CBaseBackpackItem::StartAction(CBaseBackpackItem::BackpackItemActionType, CBaseBackpackItem::BackpackItemActionTrigger)
			 *
			 * Note: Detouring as a pre-hook for changing the following per player before starting any actions:
			 * - "first_aid_kit_use_duration"
			 * - "ammo_pack_use_duration"
			 * - "cola_bottles_use_duration"
			 * - "defibrillator_use_duration"
			 * - "gas_can_use_duration"
			 * - "upgrade_pack_use_duration"
			 * Note: Detouring as a post-hook for changing the above back to default values after starting any actions.
			 **/
			"L4DD::CBaseBackpackItem::StartAction"
			{
				"signature"	"CBaseBackpackItem::StartAction"
				"callconv"	"thiscall"
				"return"	"int"
				"this"		"entity"
				"arguments"
				{
					"actionType"
					{
						"type"		"int"
					}
					"actionTrigger"
					{
						"type"		"int"
					}
				}
			}

			"L4DD::OnVocalize"
			{
				"signature"		"Vocalize"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
				"arguments"
				{
					"a1"
					{
						"type"	"charptr"
					}
					"a2"
					{
						"type"	"float"
					}
					"a3"
					{
						"type"	"float"
					}
				}
			}

			"L4DD::CServerGameDLL::ServerHibernationUpdate"
			{
				"signature"		"CServerGameDLL::ServerHibernationUpdate"
				"callconv"		"thiscall"
				"return"		"bool"
				"this"			"address"
				"arguments"
				{
					"bHibernating"
					{
						"type"	"bool"
					}
				}
			}

			// Addons Disabler
			"L4DD::CBaseServer::FillServerInfo"
			{
				"signature"		"CBaseServer::FillServerInfo"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"address"
				"arguments"
				{
					"a1"
					{
						"type"	"int"
					}
				}
			}



			// UNUSED
			"L4DD::InfectedShoved::OnShoved"
			{
				"signature"		"InfectedShoved::OnShoved"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
				"arguments"
				{
					"a1"
					{
						"type"	"int"
					}
					"a2"
					{
						"type"	"int"
					}
				}
			}

			"L4DD::CBasePlayer::WaterMove"
			{
				"signature"		"CBasePlayer::WaterMove"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"entity"
			}
		}



		// ====================================================================================================
		// ADDRESSES
		// ====================================================================================================
		"Addresses"
		{
			"CDirector"
			{
				"windows"
				{
					"signature" "CDirectorMusicBanks::OnRoundStart"
					"read" "12"
				}
				"linux"
				{
					"signature" "TheDirector"
				}
				"read" "0"
			}

			"ZombieManager"
			{
				"windows"
				{
					"signature"	"StartChangeLevel"
					"read"	"293"
				}
				"linux"
				{
					"signature" "TheZombieManager"
				}
				"read" "0"
			}

			"ServerAddr"
			{
				"windows"
				{
					"signature" "CVEngineServer::CreateFakeClient"
					"read" "8"
				}
				"linux"
				{
					"signature" "CVEngineServer::CreateFakeClient"
					"read" "12"
				}
			}

			/* Offset into CreateGameRulesObject */
			"GameRules"
			{
				"windows"
				{
					"signature" "CreateGameRulesObject"
					"read" "5"
				}
				"linux"
				{
					"signature" "g_pGameRules"
				}
				"read" "0"
			}

			"WeaponInfoDatabase"
			{
				"windows"
				{
					"signature" "ReadWeaponDataFromFileForSlot"
					"read" "75"
				}
				"linux"
				{
					"signature" "WeaponInfoDatabase"
				}
			}

			"MeleeWeaponInfoStore"
			{
				"windows"
				{
					"signature" "GiveNamedItem"
					"read" "340"
				}
				"linux"
				{
					"signature" "CMeleeWeaponInfoStore"
				}
			}

			"TheNavAreas"
			{
				"windows"
				{
					"signature" "nav_update_lighting"
					"read" "82"
				}
				"linux"
				{
					"signature" "TheNavAreas"
				}
			}

			"TerrorNavMesh"
			{
				"windows"
				{
					"signature" "CommandNavSave"
					"read" "11"
				}
				"linux"
				{
					"signature" "TheNavMesh"
				}
				"read" "0"
			}

			"L4DD::ScriptVM"
			{
				"windows"
				{
					"signature" "CDirector::GetScriptValueFloat"
					"read" "19"
				}
				"linux"
				{
					"signature" "g_pScriptVM"
				}
				"read" "0"
			}

			"VanillaModeAddress"
			{
				"windows"
				{
					"signature" "VanillaModeOffset"
				}
				"linux"
				{
					"signature" "VanillaModeOffset"
				}
			}

			"CDirector::ForceNextStage"
			{
				"windows"
				{
					"signature" "ForceNextStage"
				}
				"linux"
				{
					"signature" "ForceNextStage"
				}
			}

			"CDirector::ForceNextStage::Address"
			{
				"windows"
				{
					"signature" "CDirector::ForceNextStage"
					"read"		"163"	// Midway through nearer target call
					// "read"	"1436"	// From function start
				}
				"linux"
				{
					"signature" "CDirector::ForceNextStage"
				}
			}

			"CTerrorPlayer::CanBecomeGhost::Address"
			{
				"windows"
				{
					"signature" "CTerrorPlayer::CanBecomeGhost"
				}
				"linux"
				{
					"signature" "CTerrorPlayer::CanBecomeGhost"
				}
			}

			// Used for dynamic searching of memory address for SDKCall
			"Molotov_StrFind"
			{
				"signature"	"Molotov_StrFind"
			}

			"VomitJar_StrFind"
			{
				"signature"	"VomitJar_StrFind"
			}

			"GrenadeLauncher_StrFind"
			{
				"signature"	"GrenadeLauncher_StrFind"
			}

			"Realism_StrFind"
			{
				"signature"	"Realism_StrFind"
			}
		}



		// ====================================================================================================
		// OFFSETS
		// ====================================================================================================
		"Offsets"
		{
			// Used to block "L4D2_OnSendInRescueVehicle" and "L4D2_OnUseHealingItems" on Linux until DHooks supports object returns.
			"OS"
			{
				"windows"	"0"
				"linux"		"1"
			}



			// ADDONS ECLIPSE
			/*
				Details on finding offsets can be found here: https://github.com/ProdigySim/left4dhooks/pull/1
				Big thanks to "ProdigySim" for updating for The Last Stand update.
			*/

			// Network slot offset
			// Offset into SVC_ServerInfo struct of player slot number
			"AddonEclipse1"
			{
				"windows"	"116"
				"linux"		"108"
			}

			// Patch offset
			// Offset into SVC_ServerInfo struct of "Vanilla Mode" boolean
			"AddonEclipse2"
			{
				"windows"	"93"
				"linux"		"85"
			}

			// Lobby reservation ID
			"LobbyReservationOffset"
			{
				"windows"	"368"
				"linux"		"364"
			}



			// VIRTUAL CALLS
			"CBaseServer::GetClient"
			{
				"windows"	"6"
				"linux"		"7"
			}

			"CBaseGrenade::Detonate"
			{
				"windows"	"346"
				"linux"		"347"
			}

			/*
			* CTerrorPlayer::Deafen(float,float,float)
			*/
			"CTerrorPlayer::Deafen"
			{
				"windows"	"517"
				"linux"		"518"
			}

			/*
			* CTerrorPlayer::GetLastKnownArea() const
			*/
			"CTerrorPlayer::GetLastKnownArea"
			{
				"windows"	"330"
				"linux"		"331"
			}



			// VARIOUS OFFSETS

			// Offset to the "push" call: e.g. 68 14 D7 50 10				push	offset aMolotovProject_0 ; "Molotov projectile spawned at %f %f %f,"...
			"Molotov_OffsetPush"
			{
				"windows"	"74"
			}

			"VomitJar_OffsetPush"
			{
				"windows"	"74"
			}

			"GrenadeLauncher_OffsetPush"
			{
				"windows"	"74"
			}

			"Realism_OffsetPush"
			{
				"windows"	"60"
			}

			// USING PTR BELOW INSTEAD
			/* Offset into CDirector::AreWanderersAllowed */
			// "ScavengeModePtr"
			// {
				// "windows"	"11"	/* mov ecx, [esi+offs] */
				// "linux"		"13"	/* mov eax, [ebx+offs] */
			// }
			"ScavengeModePtr"
			{
				"windows"	"1604"
				"linux"		"1604"
			}

			"VersusModePtr"
			{
				"windows"	"1596"
				"linux"		"1596"
			}

			"ScriptedEventManagerPtr"
			{
				"windows"	"1592"
				"linux"		"1592"
			}

			"CSquirrelVM::GetValue"
			{
				"windows"	"37"
				"linux"		"36"
			}

			// Can be found in "CTerrorPlayer::SetBecomeGhostAt": *((float *)this + 2816) = s2;
			// 2816 * 4
			"CTerrorPlayer::m_flBecomeGhostAt"
			{
				"windows"	"11284"
				"linux"		"11264"
			}

			// Can be found in "CDirector::GetScriptScope(CDirector::ScriptLevels_t)"
			"m_iszScriptId"
			{
				"windows"	"968"
				"linux"		"968"
			}

			"m_rescueCheckTimer"
			{
				"windows"	"788"
				"linux"		"788"
			}

			"m_PendingMobCount"
			{
				"windows"	"528"
				"linux"		"528"
			}

			// Can be found in "CDirector::OnMapLoaded" - *((_DWORD *)v13 + 270) = RandomInt((char *)&n + 1, 6);
			"CDirector::m_nFirstClassIndex"
			{
				"linux"		"1080"
				"windows"	"1080"
			}

			"CTerrorPlayer::CanBecomeGhost::Offset"
			{
				"windows"	"2375"
				"linux"		"1585"
			}
			"CTerrorPlayer::CanBecomeGhost::Bytes"
			{
				"windows"	"232" // 0xE8
				"linux"		"232" // 0xE8
			}
			"CTerrorPlayer::CanBecomeGhost::Count"
			{
				"windows"	"5"
				"linux"		"5"
			}

			"MobSpawnTimer"
			{
				"windows"	"660"
				"linux"		"660"
			}

			"OnBeginRoundSetupTime"
			{
				"windows"	"16"
				"linux"		"16"
			}

			/* Member variable offset into CTerrorGameRules
			 *
			 * - Look for CTerrorGameRules::GetVersusMaxCompletionScore, which is ref'd
			 * - by CL4DGameStats::AddSurvivorStats--unique string "CharacterId"
			 */
			"VersusMaxCompletionScore"
			{
				"windows"	"3584"
				"linux"		"3580"
			}

			// Addons Disabler
			"VanillaModeOffset"
			{
				"windows"	"0"
				"linux"		"0"
			}

			// UNUSED
			/* Offset from ConnectClientLobbyCheck to cmp with max players check
				string #Valve_Reject_Server_Full
			 */
			"ValveRejectServerFullFirst"
			{
				"windows"	"30"	/* cmp eax, [esi+180h] -> cmp eax, imm32 */
				"linux"		"0"		/* cmp esi, [ebx+17Ch] -> cmp esi, imm32 */
			}



			// l4d_direct.inc
			// VARIOUS OFFSETS
			"m_iWitchCount"
			{
				"linux"		"444"
				"windows"	"444"
			}
			"m_iTankCount"
			{
				"linux"		"448"
				"windows"	"448"
			}
			"m_iCampaignScores"
			{
				"windows"	"8"
				"linux"		"8"
			}
			"m_fTankSpawnFlowPercent"
			{
				"windows"	"40"
				"linux"		"40"
			}
			"m_fWitchSpawnFlowPercent"
			{
				"windows"	"48"
				"linux"		"48"
			}



			// l4d_direct.inc
			"m_iTankPassedCount"
			{
				"windows"	"280"
				"linux"		"280"
			}
			"m_bTankThisRound"
			{
				"windows"	"56"
				"linux"		"56"
			}
			"m_bWitchThisRound"
			{
				"windows"	"58"
				"linux"		"58"
			}
			"OvertimeGraceTimer"
			{
				"windows"	"28"
				"linux"		"28"
			}
			// Can be found in the "CTerrorPlayer::IsInvulnerable" function
			"InvulnerabilityTimer"
			{
				"windows"	"11892" // 2.2.1.3
				"linux"		"11872" // 2.2.1.3
			}
			// Can be found near the text "TANK OFFER: Player %s has %d tickets\n" in that section above, where the line reads "mov     edx, [ebx+30A8h]" - it's this value
			"m_iTankTickets"
			{
				"windows"	"12444" // 2.2.1.3
				"linux"		"12424" // 2.2.1.3
			}
			// Can be found in the "CTerrorPlayer::GetShovePenalty" and "CTerrorPlayer::SetShovePenalty" functions
			"m_iShovePenalty"
			{
				"windows"	"11504" // 2.2.1.3
				"linux"		"11484" // 2.2.1.3
			}
			"m_fNextShoveTime"
			{
				"windows"	"11500" // 2.2.1.3
				"linux"		"11480" // 2.2.1.3
			}
			// Can be in the "CTerrorPlayer::OnRevived" function
			"m_preIncapacitatedHealth"
			{
				"windows"	"14844" // 2.2.1.3
				"linux"		"14824" // 2.2.1.3
			}
			"m_preIncapacitatedHealthBuffer"
			{
				"windows"	"14848" // 2.2.1.3
				"linux"		"14828" // 2.2.1.3
			}
			"m_maxFlames"
			{
				"windows"	"2960"
				"linux"		"2980"
				// This offset is cmp'd against 64 at the start
				// of CInferno::CreateFire. Look for 2 refs to "insect_swarm" in 1 func.
			}
			"m_fMapMaxFlowDistance"
			{
				"windows"	"1528"
				"linux"		"1524"
				// Compared against inside of the current_flow_distance ccommand.
			}
			"m_flow"
			{
				"windows"	"332"
				"linux"		"340"
				// From "CTerrorPlayer::GetFlowDistance"
			}
			"m_chapter"
			{
				"windows"	"1056"
				"linux"		"1056"
				// From "CDirector::GetMapNumber"
			}

			/* CNavArea::InheritAttributes(CNavArea *this, CNavArea *, CNavArea *) */
			"m_attributeFlags"
			{
				"windows"	"84"
				"linux"		"84"
			}

			/* TerrorNavArea::SetSpawnAttributes(TerrorNavArea *__hidden this, unsigned int) */
			"m_spawnAttributes"
			{
				"windows"	"296"
				"linux"		"300"
			}



			// l4d2timers.inc offsets
			// L4D2CountdownTimer
			"L4D2CountdownTimer_MobSpawnTimer"
			{
				"windows"	"660"
				"linux"		"660"
			}
			"L4D2CountdownTimer_SmokerSpawnTimer"
			{
				"windows"	"756"
				"linux"		"756"
			}
			"L4D2CountdownTimer_BoomerSpawnTimer"
			{
				"windows"	"768"
				"linux"		"768"
			}
			"L4D2CountdownTimer_HunterSpawnTimer"
			{
				"windows"	"780"
				"linux"		"780"
			}
			"L4D2CountdownTimer_SpitterSpawnTimer"
			{
				"windows"	"792"
				"linux"		"792"
			}
			"L4D2CountdownTimer_JockeySpawnTimer"
			{
				"windows"	"804"
				"linux"		"804"
			}
			"L4D2CountdownTimer_ChargerSpawnTimer"
			{
				"windows"	"816"
				"linux"		"816"
			}
			"L4D2CountdownTimer_VersusStartTimer"
			{
				"windows"	"28"
				"linux"		"28"
			}
			"L4D2CountdownTimer_UpdateMarkersTimer"
			{
				"windows"	"80"
				"linux"		"80"
			}

			// L4D2IntervalTimer
			"L4D2IntervalTimer_SmokerDeathTimer"
			{
				"windows"	"500"
				"linux"		"500"
			}
			"L4D2IntervalTimer_BoomerDeathTimer"
			{
				"windows"	"508"
				"linux"		"508"
			}
			"L4D2IntervalTimer_HunterDeathTimer"
			{
				"windows"	"516"
				"linux"		"516"
			}
			"L4D2IntervalTimer_SpitterDeathTimer"
			{
				"windows"	"524"
				"linux"		"524"
			}
			"L4D2IntervalTimer_JockeyDeathTimer"
			{
				"windows"	"532"
				"linux"		"532"
			}
			"L4D2IntervalTimer_ChargerDeathTimer"
			{
				"windows"	"540"
				"linux"		"540"
			}



			// l4d2weapons.inc offsets - Offsets can be found in: "CTerrorWeaponInfo::Parse" - "CCSWeaponInfo::Parse" - "FileWeaponInfo_t::Parse" - "CTerrorGun::DoViewPunch"
			// L4D2IntWeapon
			"L4D2IntWeapon_Damage"
			{
				"windows"	"2508"
				"linux"		"2508"
			}
			"L4D2IntWeapon_Bullets"
			{
				"windows"	"2520"
				"linux"		"2520"
			}
			"L4D2IntWeapon_ClipSize"
			{
				"windows"	"352"
				"linux"		"352"
			}
			"L4D2IntWeapon_DefaultSize"
			{
				"windows"	"360"
				"linux"		"360"
			}
			"L4D2IntWeapon_Bucket"
			{
				"windows"	"344"
				"linux"		"344"
			}
			"L4D2IntWeapon_Tier"
			{
				"windows"	"3048"
				"linux"		"3048"
			}

			// L4D2FloatWeapon
			"L4D2FloatWeapon_MaxPlayerSpeed"
			{
				"windows"	"2192"
				"linux"		"2192"
			}
			"L4D2FloatWeapon_SpreadPerShot"
			{
				"windows"	"3088"
				"linux"		"3088"
			}
			"L4D2FloatWeapon_MaxSpread"
			{
				"windows"	"3092"
				"linux"		"3092"
			}
			"L4D2FloatWeapon_SpreadDecay"
			{
				"windows"	"3096"
				"linux"		"3096"
			}
			"L4D2FloatWeapon_MinDuckingSpread"
			{
				"windows"	"3100"
				"linux"		"3100"
			}
			"L4D2FloatWeapon_MinStandingSpread"
			{
				"windows"	"3104"
				"linux"		"3104"
			}
			"L4D2FloatWeapon_MinInAirSpread"
			{
				"windows"	"3108"
				"linux"		"3108"
			}
			"L4D2FloatWeapon_MaxMovementSpread"
			{
				"windows"	"3112"
				"linux"		"3112"
			}
			"L4D2FloatWeapon_PenetrationNumLayers"
			{
				"windows"	"3144"
				"linux"		"3144"
			}
			"L4D2FloatWeapon_PenetrationPower"
			{
				"windows"	"3148"
				"linux"		"3148"
			}
			"L4D2FloatWeapon_PenetrationMaxDist"
			{
				"windows"	"3152"
				"linux"		"3152"
			}
			"L4D2FloatWeapon_CharPenetrationMaxDist"
			{
				"windows"	"3156"
				"linux"		"3156"
			}
			"L4D2FloatWeapon_GainRange"
			{
				"windows"	"3160"
				"linux"		"3160"
			}
			"L4D2FloatWeapon_Range"
			{
				"windows"	"2512"
				"linux"		"2512"
			}
			"L4D2FloatWeapon_RangeModifier"
			{
				"windows"	"2516"
				"linux"		"2516"
			}
			"L4D2FloatWeapon_CycleTime"
			{
				"windows"	"2524"
				"linux"		"2524"
			}
			"L4D2FloatWeapon_ScatterPitch"
			{
				"windows"	"3116"
				"linux"		"3116"
			}
			"L4D2FloatWeapon_ScatterYaw"
			{
				"windows"	"3120"
				"linux"		"3120"
			}
			"L4D2FloatWeapon_VerticalPunch"
			{
				"windows"	"3076"
				"linux"		"3076"
			}
			"L4D2FloatWeapon_HorizontalPunch"
			{
				"windows"	"3080"
				"linux"		"3080"
			}
			"L4D2FloatWeapon_ReloadDuration"
			{
				"windows"	"3128"
				"linux"		"3128"
			}

			// L4D2BoolMeleeWeapon
			"L4D2BoolMeleeWeapon_Decapitates"
			{
				"windows"	"300"
				"linux"		"300"
			}

			// L4D2IntMeleeWeapon
			"L4D2IntMeleeWeapon_DamageFlags"
			{
				"windows"	"292"
				"linux"		"292"
			}
			"L4D2IntMeleeWeapon_RumbleEffect"
			{
				"windows"	"296"
				"linux"		"296"
			}

			// L4D2FloatMeleeWeapon
			"L4D2FloatMeleeWeapon_Damage"
			{
				"windows"	"288"
				"linux"		"288"
			}
			"L4D2FloatMeleeWeapon_RefireDelay"
			{
				"windows"	"4"
				"linux"		"4"
			}
			"L4D2FloatMeleeWeapon_WeaponIdleTime"
			{
				"windows"	"3148"
				"linux"		"3148"
			}
		}



		// ====================================================================================================
		// SIGNATURES
		// ====================================================================================================
		"Signatures"
		{
			// =========================
			// SILVERS SIGS
			// =========================
			/* GetWeaponInfo(CSWeaponID) */
			"GetWeaponInfo"
			{
				"library"		"server"
				"linux"			"@_Z13GetWeaponInfo10CSWeaponID"
				"windows"		"\x55\x8B\x2A\x53\x8B\x2A\x2A\x85\x2A\x75\x2A\x33\x2A\x5B\x5D\xC3\x80"
				/* 55 8B ? 53 8B ? ? 85 ? 75 ? 33 ? 5B 5D C3 80 */
				/* Search "weapon_reparse_server" for "CTerrorWeaponInfo::Reload", inside top call */
			}

			/* CMeleeWeaponInfoStore::GetMeleeWeaponInfo(CMeleeWeaponInfoStore *this, int) */
			"CMeleeWeaponInfoStore::GetMeleeWeaponInfo"
			{
				"library"		"server"
				"linux"			"@_ZN21CMeleeWeaponInfoStore18GetMeleeWeaponInfoEi"
				"windows"		"\x55\x8B\x2A\x83\x2A\x2A\x8B\x2A\x2A\x56\x8B\x2A\x8D\x2A\x2A\x51\x8D\x2A\x2A\x89\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x83\x2A\x2A\x75"
				/* 55 8B ? 83 ? ? 8B ? ? 56 8B ? 8D ? ? 51 8D ? ? 89 ? ? E8 ? ? ? ? 83 ? ? 75 */
				/* Search "models/props_junk/gascan001a.mdl", one of xrefs, compare to NIX code easily found. */
			}

			/*
			* KeyValues *CTerrorGameRules::GetMissionInfo(void)
			*/
			"CTerrorGameRules::GetMissionInfo"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules14GetMissionInfoEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x01\x8B\x50\x28\x56\xFF\xD2\x8B\x10\x8B\xC8\x8B\x42"
				/* 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 8B 01 8B 50 28 56 FF D2 8B 10 8B C8 8B 42 */
			}

			/*
			* Music::Play(Music *this, const char *, int, float, bool, bool)
			*/
			"Music::Play"
			{
				"library"	"server"
				"linux"		"@_ZN5Music4PlayEPKcifbb"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x83\x2A\x2A\x00\x53\x8B\x2A\x2A\x56\x57"
				/* ? ? ? ? ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? A1 ? ? ? ? 83 ? ? 00 53 8B ? ? 56 57 */
				/* Search "Invalid emit entity index: %i\n" */
			}

			/*
			* Music::StopPlaying(Music *this, const char *, float, bool)
			*/
			"Music::StopPlaying"
			{
				"library"	"server"
				"linux"		"@_ZN5Music11StopPlayingEPKcfb"
				"windows"	"\x55\x8B\x2A\x83\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x83\x2A\x2A\x00\x56\x8B\x2A\x89\x2A\x2A\x0F\x84\x2A\x01\x2A\x2A\x8B"
				/* 55 8B ? 83 ? ? A1 ? ? ? ? 83 ? ? 00 56 8B ? 89 ? ? 0F 84 ? 01 ? ? 8B */
				/* Search "checkpoint_0" call below. */
				// Windows signature might break on updates.
			}

			/*
			* CEntityDissolve::Create(CBaseEntity *pTarget, const char *pMaterialName, float flStartTime, int nDissolveType, bool *pRagdollCreated)
			*/
			"CEntityDissolve::Create"
			{
				"library"		"server"
				"linux"			"@_ZN15CEntityDissolve6CreateEP11CBaseEntityPKcfiPb"
				"windows"		"\x55\x8B\xEC\x8B\x45\x18\x81\xEC\xC0\x00\x00\x00"
				/* 55 8B EC 8B 45 18 81 EC C0 00 00 00 */
				/* Search: "sprites/blueglow1.vmt" */
			}

			/*
			*  CTerrorPlayer::OnITExpired(void)
			*/
			"CTerrorPlayer::OnITExpired"
			{
				"library"		"server"
				"linux"			"@_ZN13CTerrorPlayer11OnITExpiredEv"
				"windows"		"\x56\x57\x8B\x2A\xF3\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x0F\x2A\x2A\x2A\x2A\x2A\x2A\x8D\x2A\x2A\x2A\x2A\x2A\x9F\xF6\x2A\x2A\x7B\x2A\x8B\x2A\x2A\x8B\x2A\x8D\x2A\x2A\x56\xFF\x2A\xF3\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xF3\x2A\x2A\x2A\x8B\x2A\x6A"
				/* 56 57 8B ? F3 ? ? ? ? ? ? ? 0F ? ? ? ? ? ? 8D ? ? ? ? ? 9F F6 ? ? 7B ? 8B ? ? 8B ? 8D ? ? 56 FF ? F3 ? ? ? ? ? ? ? F3 ? ? ? 8B ? 6A */
				/* Search: "PlayerVomitExpired" */
				// Search: "Spitter projectile spawned at %f %f %f, velocity %f %f %f"
			}

			/*
			 * CBaseEntity::WorldSpaceCenter(CBaseEntity *this)
			 */
			"CBaseEntity::WorldSpaceCenter"
			{
				"library"	"server"
				"linux"		"@_ZNK11CBaseEntity16WorldSpaceCenterEv"
				"windows"	"\x56\x57\x8D\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\xF3"
				/* 56 57 8D ? ? ? ? ? E8 ? ? ? ? 8B ? E8 ? ? ? ? F3 */
				/* Search: "%sCallChain <- CSimpleCallChainer(\"%s\", self.GetScriptScope().weakref(), true)" use VTable to count up (about 38 entries). */
			}

			/*
			 * CBaseEntity::ApplyLocalAngularVelocityImpulse(CBaseEntity *this, const Vector *a2)
			 */
			"CBaseEntity::ApplyLocalAngularVelocityImpulse"
			{
				"library"	"server"
				"linux"		"@_ZN11CBaseEntity32ApplyLocalAngularVelocityImpulseERK6Vector"
				"windows"	"\x55\x8B\x2A\xB8\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\xF3\x0F\x2A\x2A\x2A\x2A\x2A\x2A\x57\x8B"
				/* 55 8B ? B8 ? ? ? ? E8 ? ? ? ? F3 0F ? ? ? ? ? ? 57 8B */
				/* Search: "Molotov.Throw" for CMolotovProjectile::Create function. Above string is call. */
			}

			/*
			* CTerrorGameRules::HasPlayerControlledZombies()
			*/
			"CTerrorGameRules::HasPlayerControlledZombies"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules26HasPlayerControlledZombiesEv"
				"windows"	"\xF7\x05\x2A\x2A\x2A\x2A\x00\x10\x00\x00\x74\x2A\xB8\x2A\x2A\x2A\x2A\xEB\x2A\xA1\x2A\x2A\x2A\x2A\x8B\x40\x24\x85\xC0\x75\x2A\xB8\x2A\x2A\x2A\x2A\x8B\x0D\x2A\x2A\x2A\x2A\x8B\x11\x50\x8B\x42\x10\xFF\xD0\x85\xC0\x74\x2A\x6A\x00\x68\x2A\x2A\x2A\x2A\x8B\xC8\xE8\x2A\x2A\x2A\x2A\x85\xC0\x7E"
				/* F7 05 ? ? ? ? 00 10 00 00 74 ? B8 ? ? ? ? EB ? A1 ? ? ? ? 8B 40 24 85 C0 75 ? B8 ? ? ? ? 8B 0D ? ? ? ? 8B 11 50 8B 42 10 FF D0 85 C0 74 ? 6A 00 68 ? ? ? ? 8B C8 E8 ? ? ? ? 85 C0 7E */
				/* Search "playercontrolledzombies". */
			}

			/*
			*  CInferno::StartBurning(Vector const&, Vector const&, Vector const&, int)
			*  Search: "Inferno.StartSweeten"
			*/
			"CInferno::StartBurning"
			{
				"library"	"server"
				"linux"		"@_ZN8CInferno12StartBurningERK6VectorS2_S2_i"
				"windows"	"\x55\x8B\x2A\x83\x2A\x2A\x53\x56\x8B\x2A\x83\x2A\x2A\x2A\x2A\x2A\x2A\x57\x75\x2A\x8B"
				/* 55 8B ? 83 ? ? 53 56 8B ? 83 ? ? ? ? ? ? 57 75 ? 8B */
			}

			/*
			*  CPipeBombProjectile::Create(Vector  const&, QAngle  const&, Vector  const&, Vector  const&, CBaseCombatCharacter *, float)
			*  Search: "BEEP_CONTEXT"
			*/
			"CPipeBombProjectile::Create"
			{
				"library"	"server"
				"linux"		"@_ZN19CPipeBombProjectile6CreateERK6VectorRK6QAngleS2_S2_P20CBaseCombatCharacterf"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x53\x8B\x2A\x2A\x56\x57\x50\x51\x53\x68\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x68\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B"
				/* ? ? ? ? ? ? 8B ? ? 53 8B ? ? 56 57 50 51 53 68 ? ? ? ? E8 ? ? ? ? 8B ? ? ? ? ? 83 ? ? ? ? ? ? 8B ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 68 ? ? ? ? E8 ? ? ? ? 8B */
			}

			/*
			*  CSpitterProjectile::Create(Vector  const&,QAngle  const&,Vector  const&,Vector  const&,CBaseCombatCharacter *)
			*/
			"CSpitterProjectile::Create"
			{
				"library"	"server"
				"linux"		"@_ZN18CSpitterProjectile6CreateERK6VectorRK6QAngleS2_S2_P20CBaseCombatCharacter"
				"windows"	"\x55\x8B\x2A\x8B\x2A\x2A\x8B\x2A\x2A\x53\x8B\x2A\x2A\x56\x57\x50\x51\x53\x68\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x68\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\xD9\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x8B\x2A\xD9\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x57\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x57\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x57"
				/* 55 8B ? 8B ? ? 8B ? ? 53 8B ? ? 56 57 50 51 53 68 ? ? ? ? E8 ? ? ? ? 8B ? ? ? ? ? 83 ? ? ? ? ? ? 8B ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 68 ? ? ? ? E8 ? ? ? ? D9 ? ? ? ? ? 83 ? ? 8B ? D9 ? ? E8 ? ? ? ? 57 8B ? E8 ? ? ? ? 57 8B ? E8 ? ? ? ? ? ? ? 57 */
			}

			/*
			*  CMolotovProjectile::Create(int, int, int, int, CBaseEntity *)
			*  Search: "Molotov projectile spawned at %f %f %f"
			*/
			"CMolotovProjectile::Create"
			{
				"library"	"server"
				"linux"		"@_ZN18CMolotovProjectile6CreateERK6VectorRK6QAngleS2_S2_P20CBaseCombatCharacter"
				/* Windows signature is extremely long to be unique without using bytes that may change in game updates. */
			}
			"Molotov_StrFind"
			{
				"library"		"server"
				"windows"		"Molotov projectile"
				/* Search for the literal string to then reverse bytes and search for that address. */
			}

			/*
			*  CVomitJarProjectile::Create(int, int, int, int, CBaseEntity *)
			*  Search: "VomitJar projectile spawned at %f %f %f"
			*/
			"CVomitJarProjectile::Create"
			{
				"library"	"server"
				"linux"		"@_ZN19CVomitJarProjectile6CreateERK6VectorRK6QAngleS2_S2_P20CBaseCombatCharacter"
				/* Windows signature is extremely long to be unique without using bytes that may change in game updates. */
			}
			"VomitJar_StrFind"
			{
				"library"		"server"
				"windows"		"VomitJar projectile"
				/* Search for the literal string to then reverse bytes and search for that address. */
			}

			/*
			*  CGrenadeLauncher_Projectile::Create(int, int, int, int, CBaseEntity *, int)
			*  Search: "VomitJar projectile spawned at %f %f %f"
			*/
			"CGrenadeLauncher_Projectile::Create"
			{
				"library"	"server"
				"linux"		"@_ZN27CGrenadeLauncher_Projectile6CreateERK6VectorRK6QAngleS2_S2_P20CBaseCombatCharacteri"
				/* Windows signature is extremely long to be unique without using bytes that may change in game updates. */
			}
			"GrenadeLauncher_StrFind"
			{
				"library"		"server"
				"windows"		"CGrenadeLauncher_Projectile spawned"
				/* Search for the literal string to then reverse bytes and search for that address. */
			}

			/*
			*  CPipeBombProjectile::Detonate(CPipeBombProjectile *this)
			*  Search: "weapon_pipebomb_dirt"
			*/
			"CPipeBombProjectile::Detonate"
			{
				"library"	"server"
				"linux"		"@_ZN19CPipeBombProjectile8DetonateEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x53\x56\x8B\x2A\x8B\x2A\x2A\x2A\x2A\x2A\xC1\x2A\x2A\x57\xA8\x2A\x74\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x8D"
				/* ? ? ? ? ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 53 56 8B ? 8B ? ? ? ? ? C1 ? ? 57 A8 ? 74 ? E8 ? ? ? ? 8B ? ? ? ? ? 8B ? ? ? ? ? 8B ? ? ? ? ? 8D */
			}

			/*
			*  CMolotovProjectile::Detonate(CMolotovProjectile *this)
			*  Search: "hegrenade_detonate" - the function that contains "Molotov.Loop"
			*/
			"CMolotovProjectile::Detonate"
			{
				"library"	"server"
				"linux"		"@_ZN18CMolotovProjectile8DetonateEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x55\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x81\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x56\x57\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\xF6"
				/* ? ? ? ? ? ? 83 ? ? 83 ? ? 55 8B ? ? 89 ? ? ? 8B ? 81 ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 56 57 8B ? E8 ? ? ? ? 8B ? F6 */
			}

			/*
			*  CVomitJarProjectile::Detonate(CVomitJarProjectile *this)
			*  Search: "CedaJar.Explode"
			*/
			"CVomitJarProjectile::Detonate"
			{
				"library"	"server"
				"linux"		"@_ZN19CVomitJarProjectile8DetonateEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x56\x57\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\xF6\x2A\x2A\x2A\x0F\x85"
				/* ? ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 56 57 8B ? E8 ? ? ? ? 8B ? F6 ? ? ? 0F 85 */
			}

			/*
			 * CTerrorPlayer::OnPouncedOnSurvivor(CTerrorPlayer *this, CTerrorPlayer *)
			 */
			"CTerrorPlayer::OnPouncedOnSurvivor"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer19OnPouncedOnSurvivorEPS_"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x55\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x81\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x83\x2A\x2A\x00\x56\x57\x8B\x2A\x2A\x8B"
				/* ? ? ? ? ? ? 83 ? ? 83 ? ? 55 8B ? ? 89 ? ? ? 8B ? 81 ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? A1 ? ? ? ? 83 ? ? 00 56 57 8B ? ? 8B */
				/* Search: "%s pounced on %s, %d damage interrupts" */ // Found by "SilverShot".
			}

			/*
			 * CTerrorPlayer::GrabVictimWithTongue(CTerrorPlayer *this, CTerrorPlayer *)
			 */
			"CTerrorPlayer::GrabVictimWithTongue"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer20GrabVictimWithTongueEPS_"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x55\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x83\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x83\x2A\x2A\x2A\x56\x8B\x2A\x57\x89\x2A\x2A\x0F\x85\x2A\x2A\x2A\x2A\xE8"
				/* ? ? ? ? ? ? 83 ? ? 83 ? ? 55 8B ? ? 89 ? ? ? 8B ? 83 ? ? A1 ? ? ? ? 83 ? ? ? 56 8B ? 57 89 ? ? 0F 85 ? ? ? ? E8 */
				/* Search "Tongue grab starting." */
			}

			/*
			 * CTerrorPlayer::OnLeptOnSurvivor(CTerrorPlayer*) - Jockey hit Survivor function call
			 */
			"CTerrorPlayer::OnLeptOnSurvivor"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer16OnLeptOnSurvivorEPS_"
				"windows"	"\x55\x8B\x2A\xA1\x2A\x2A\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x2A\x57\x8B\x2A\x0F\x85\x2A\x2A\x2A\x2A\x56"
				/* 55 8B ? A1 ? ? ? ? 83 ? ? 83 ? ? ? 57 8B ? 0F 85 ? ? ? ? 56 */
				/* Search: "JockeyZombie.Ride" */ // Found by "SilverShot".
			}

			/*
			*  CTerrorPlayer::OnAdrenalineUsed(CTerrorPlayer *this, float)
			*/
			"CTerrorPlayer::OnAdrenalineUsed"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer16OnAdrenalineUsedEf"
				"windows"	"\x55\x8B\x2A\x51\x53\x56\x8B\x2A\x8D\x2A\x2A\x2A\x2A\x2A\x57\x8B\x2A\xE8"
				/* 55 8B ? 51 53 56 8B ? 8D ? ? ? ? ? 57 8B ? E8 */
				/* Search: "%s used adrenaline\n" call is 3rd above, match to Linux. */
			}

			/**
			 * Thanks to "Psyk0tik" from: https://github.com/Psykotikism/L4D1-2_Signatures
			 * CTerrorPlayer::Extinguish()
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. In IDA Pro, go to the ".rdata" section of the Windows binary.
			 * 3. Search for "CTerrorPlayer::`vftable'" to jump to the "CTerrorPlayer" vtable.
			 * 4. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 5. Look for the target function in the Windows binary.
			 **/
			"CTerrorPlayer::Extinguish"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer10ExtinguishEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x56\x57\x8B\x2A\x8B\xB7\x2A\x2A\x2A\x2A\x68"
				/* ? ? ? ? ? ? 53 56 57 8B ? 8B B7 ? ? ? ? 68 */
			}

			/**
			 * CTerrorPlayer::FindUseEntity(float, float, float, bool *, bool)
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. In IDA Pro, go to the ".rdata" section of the Windows binary.
			 * 3. Search for "CTerrorPlayer::`vftable'" to jump to the "CTerrorPlayer" vtable.
			 * 4. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 5. Look for the target function in the Windows binary.
			 **/
			"CTerrorPlayer::FindUseEntity"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer13FindUseEntityEfffPbb"
				"mac"		"@_ZN13CTerrorPlayer13FindUseEntityEfffPbb"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x0F"
				/* ? ? ? ? ? ? ? ? E8 ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 0F */
			}

			/*
			*  Script_ForceVersusStart(void)
			*/
			"Script_ForceVersusStart"
			{
				"library"	"server"
				"linux"		"@_ZL23Script_ForceVersusStartv"
				"windows"	"\xA1\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x74\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\xE9"
				/* A1 ? ? ? ? 8B ? ? ? ? ? E8 ? ? ? ? 84 ? 74 ? 8B ? ? ? ? ? 8B ? ? ? ? ? E9 */
			}

			/*
			*  Script_ForceSurvivalStart(void)
			*/
			"Script_ForceSurvivalStart"
			{
				"library"	"server"
				"linux"		"@_ZL25Script_ForceSurvivalStartv"
				"windows"	"\xE8\x2A\x2A\x2A\x2A\x84\x2A\x74\x2A\xA1\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x80\x2A\x00\x75"
				/* E8 ? ? ? ? 84 ? 74 ? A1 ? ? ? ? 8B ? ? ? ? ? 80 ? 00 75 */
			}

			/*
			*  Script_ForceScavengeStart(void)
			*/
			"Script_ForceScavengeStart"
			{
				"library"	"server"
				"linux"		"@_ZL25Script_ForceScavengeStartv"
				"windows"	"\xE8\x2A\x2A\x2A\x2A\x84\x2A\x74\x2A\xA1\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x80\x2A\x2A\x00\x75\x2A\xE8"
				/* E8 ? ? ? ? 84 ? 74 ? A1 ? ? ? ? 8B ? ? ? ? ? 80 ? ? 00 75 ? E8 */
			}

			/*
			*  ScriptClassDesc_t * GetScriptDesc<CDirector>(CDirector *)
			*/
			"CDirector::ForceNextStage"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector14ForceNextStageEv"
				// Midway through nearer target call
				"windows"	"\x89\x2A\x2A\xC7\x2A\x2A\x2A\x2A\x2A\x2A\xC7\x2A\x2A\x2A\x2A\x2A\x2A\x89\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x50\xE8\x2A\x2A\x2A\x2A\x33\x2A\x8D"
				/* 89 ? ? C7 ? ? ? ? ? ? C7 ? ? ? ? ? ? 89 ? ? A1 ? ? ? ? 50 E8 ? ? ? ? 33 ? 8D */

				// FUnction start
				// "windows"	"\x80\x2A\x2A\x2A\x2A\x2A\x00\x0F\x85\x2A\x2A\x2A\x2A\x53\x56\xB8\x2A\x2A\x2A\x2A\xA3"
				/* 80 ? ? ? ? ? 00 0F 85 ? ? ? ? 53 56 B8 ? ? ? ? A3 */
				/* Search "Push the ScriptedMode to next stage" */
			}

			/*
			*  CDirector::ForceNextStage(CDirector *this)
			*  Note: Unused since breaks every update, windows has a new method above to get the address
			*/
			"ForceNextStage"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector14ForceNextStageEv"
				"windows"	"\x8B\x2A\x88\x05\x00\x00\xE9\x2A\x9A\x01\x00"
				/* 8B ? 88 05 00 00 E9 ? 9A 01 00 */
				/* Search "ForceNextStage" call below of XRef */
			}

			/*
			*  CDirector::IsTankInPlay(CDirector *this)
			*/
			"CDirector::IsTankInPlay"
			{
				"library"	"server"
				"linux"		"@_ZNK9CDirector12IsTankInPlayEv"
				"windows"	"\x33\x2A\x39\x2A\x2A\x01\x2A\x2A\x0F\x9F\x2A\xC3"
				/* 33 ? 39 ? ? 01 ? ? 0F 9F ? C3 */
				/* Search "IsTankInPlay" call below */
			}

			/*
			*  CDirector::GetFurthestSurvivorFlow(CDirector *this)
			*/
			"CDirector::GetFurthestSurvivorFlow"
			{
				"library"	"server"
				"linux"		"@_ZNK9CDirector23GetFurthestSurvivorFlowEv"
				"windows"	"\xD9\x2A\x4C\x02\x00\x00\xC3"
				/* D9 ? 4C 01 00 00 C3 */
				/* Search "GetFurthestSurvivorFlow" call below */
			}

			/*
			*  ZombieManager::GetRandomPZSpawnPosition(ZombieManager *_ZombieManager, int zombieClass, int attempts, int a4, int a5)
			*/
			"ZombieManager::GetRandomPZSpawnPosition"
			{
				"library"	"server"
				"linux"		"@_ZNK13ZombieManager24GetRandomPZSpawnPositionE15ZombieClassTypeiP13CTerrorPlayerP6Vector"
				"windows"	"\x55\x8B\x2A\x83\x2A\x2A\x53\x57\x8B\x2A\x2A\x8B\x2A\x89\x2A\x2A\x85\x2A\x75\x2A\x5F\x32"
				/* 55 8B ? 83 ? ? 53 57 8B ? ? 8B ? 89 ? ? 85 ? 75 ? 5F 32 */
				/* Search "ZombieManager::GetRandomPZSpawnPosition" */
			}

			/*
			*  CNavMesh::GetNearestNavArea(CNavMesh *this, const Vector *, bool, float, bool, bool, bool)
			*/
			"CNavMesh::GetNearestNavArea"
			{
				"library"	"server"
				"linux"		"@_ZNK8CNavMesh17GetNearestNavAreaERK6Vectorbfbbb"
				"windows"	"\x55\x8B\x2A\x81\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x56\x8B\x2A\x83\x2A\x2A\x2A\x57\x8B"
				/* 55 8B ? 81 ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 56 8B ? 83 ? ? ? 57 8B */
				/* Search "Couldn't find a %s Spawn position in %d tries\n", some calls below */
			}

			/*
			*  TerrorNavArea::FindRandomSpot(TerrorNavArea *this)
			*/
			"TerrorNavArea::FindRandomSpot"
			{
				"library"	"server"
				"linux"		"@_ZNK13TerrorNavArea14FindRandomSpotEv"
				"windows"	"\x55\x8B\x2A\xF3\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x56\x8B\x2A\xF3\x2A\x2A\x2A\x2A\xF3\x2A\x2A\x2A\x2A\x0F"
				/* 55 8B ? F3 ? ? ? ? ? ? ? 83 ? ? 56 8B ? F3 ? ? ? ? F3 ? ? ? ? 0F */
				/* Search "Couldn't find a %s Spawn position in %d tries\n", some calls below */
			}

			"CTerrorPlayer::WarpToValidPositionIfStuck"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer26WarpToValidPositionIfStuckEv.part.200"
				"windows"	"\x55\x8B\x2A\x81\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x56\x8B\x2A\x80\x2A\x2A\x2A\x2A\x2A\x2A\x0F\x85\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x53\x57"
				/* 55 8B ? 81 ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 56 8B ? 80 ? ? ? ? ? ? 0F 85 ? ? ? ? 8B ? 8B ? ? ? ? ? 53 57 */
				/* Search: "unsticking %s from %.1f %.1f %.1f to %.1f %.1f %.1f\n" */
			}

			/**
			* IsVisibleToPlayer(Vector const&, CBasePlayer *, int, int, float, CBaseEntity const*, TerrorNavArea **, bool *)
			*
			* Thanks Psyk0tik help
			* How to find on Windows:
			* 1. Search for the "Tank/Witch threat spawn: No non-visible valid areas between threat area and goal area! Choosing random area.\n" string.
			* 2. The string can only be found in "CDirector::OnThreatEncountered".
			* 3. The function "CDirector::OnThreatEncountered" calls "CDirectorTacticalServices::IsSpawnLocationVisibleToTeam" with the values "2" and "3" passed to it.
			* 4. The last function call in "CDirectorTacticalServices::IsSpawnLocationVisibleToTeam" should be this function.
			**/
			"IsVisibleToPlayer"
			{
				"library"	"server"
				"linux"		"@_Z17IsVisibleToPlayerRK6VectorP11CBasePlayeriifPK11CBaseEntityPP13TerrorNavAreaPb"
				"windows"	"\x55\x8B\x2A\x81\xEC\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x8B\x2A\x2A\x8B\x2A\x2A\x53\x8B\x2A\x2A\x56\x8B\x2A\x2A\xC6"
				/* 55 8B ? 81 EC ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 8B ? ? 8B ? ? 53 8B ? ? 56 8B ? ? C6 */
			}

			/*
			*  CDirector::HasAnySurvivorLeftSafeArea(CDirector *this)
			*/
			"CDirector::HasAnySurvivorLeftSafeArea"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector26HasAnySurvivorLeftSafeAreaEv"
				"windows"	"\x8A\x2A\x60\x01\x00\x00\xC3"
				/* 8A ? 60 01 00 00 C3 */
				/* Search "I've walked out of the checkpoint" call below */
			}

			/*
			*  CDirector::IsAnySurvivorInStartArea(CDirector *__hidden this)
			*/
			"CDirector::IsAnySurvivorInStartArea"
			{
				"library"	"server"
				"linux"		"@_ZNK9CDirector24IsAnySurvivorInStartAreaEv"
				"windows"	"\x55\x8B\x2A\x83\x2A\x2A\xF3\x0F\x2A\x2A\x2A\x2A\x2A\x2A\x8D\x2A\x2A\x50\xF3"
				/* 55 8B ? 83 ? ? F3 0F ? ? ? ? ? ? 8D ? ? 50 F3 */
				/* Search "FPlayerCanRespawn: pPlayer=0" 2nd function, call below, above "HasAnySurvivorLeftSafeArea" */
			}

			/*
			*  TerrorNavMesh::GetInitialCheckpoint(TerrorNavMesh *this)
			*/
			"TerrorNavMesh::GetInitialCheckpoint"
			{
				"library"	"server"
				"linux"		"@_ZNK13TerrorNavMesh20GetInitialCheckpointEv"
				"windows"	"\x55\x8B\x2A\x83\x2A\x2A\x89\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x75\x2A\x33\x2A\x8B"
				/* 55 8B ? 83 ? ? 89 ? ? 8B ? ? ? ? ? E8 ? ? ? ? 84 ? 75 ? 33 ? 8B */
				/* Search "************\nMost gross danger! Cannot find Landmark named %s!\n************" */
			}

			/*
			*  TerrorNavMesh::IsInInitialCheckpoint_NoLandmark(TerrorNavArea *)const
			*/
			"TerrorNavMesh::IsInInitialCheckpoint_NoLandmark"
			{
				"library"	"server"
				"linux"		"@_ZNK13TerrorNavMesh32IsInInitialCheckpoint_NoLandmarkEP13TerrorNavArea"
				"windows"	"\x55\x8B\x2A\xA1\x2A\x2A\x2A\x2A\x53\x8B\x2A\x2A\x2A\x2A\x2A\x57\x32\x2A\x33\x2A\x85\x2A\x7E\x2A\x8B\x2A\x2A\x56\x8D\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x75"
				/* 55 8B ? A1 ? ? ? ? 53 8B ? ? ? ? ? 57 32 ? 33 ? 85 ? 7E ? 8B ? ? 56 8D ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 75 */
				/* Found within "CTerrorGameRules::GetVersusCompletion" (signature for that function is in this GameData) */
			}

			/*
			*  TerrorNavMesh::IsInExitCheckpoint_NoLandmark(TerrorNavArea *)const
			*/
			"TerrorNavMesh::IsInExitCheckpoint_NoLandmark"
			{
				"library"	"server"
				"linux"		"@_ZNK13TerrorNavMesh29IsInExitCheckpoint_NoLandmarkEP13TerrorNavArea"
				"windows"	"\x55\x8B\x2A\xA1\x2A\x2A\x2A\x2A\x53\x8B\x2A\x2A\x2A\x2A\x2A\x57\x32\x2A\x33\x2A\x85\x2A\x7E\x2A\x8B\x2A\x2A\x56\x8D\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x74"
				/* 55 8B ? A1 ? ? ? ? 53 8B ? ? ? ? ? 57 32 ? 33 ? 85 ? 7E ? 8B ? ? 56 8D ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 74 */
				/* Found within "CTerrorGameRules::GetVersusCompletion" (signature for that function is in this GameData) */
			}

			/*
			*  Checkpoint::ContainsArea(TerrorNavArea *)const
			*/
			"Checkpoint::ContainsArea"
			{
				"library"	"server"
				"linux"		"@_ZNK10Checkpoint12ContainsAreaEP13TerrorNavArea"
				"windows"	"\x55\x8B\x2A\x8B\x2A\x2A\x33\x2A\x56\x85\x2A\x7E\x2A\x8B\x2A\x8B\x2A\x2A\x39\x2A\x74"
				/* 55 8B ? 8B ? ? 33 ? 56 85 ? 7E ? 8B ? 8B ? ? 39 ? 74 */
				/* Search "We're leaving the checkpoint to help a teammate" call is near start of function */
			}

			/*
			*  TerrorNavMesh::GetLastCheckpoint(TerrorNavMesh *this)
			*/
			"TerrorNavMesh::GetLastCheckpoint"
			{
				"library"	"server"
				"linux"		"@_ZNK13TerrorNavMesh17GetLastCheckpointEv"
				"windows"	"\x55\x8B\x2A\x51\x8B\x2A\x2A\x2A\x2A\x2A\x56\x8B\x2A\x2A\x2A\x2A\x2A\x85\x2A\x74\x2A\xE8"
				/* 55 8B ? 51 8B ? ? ? ? ? 56 8B ? ? ? ? ? 85 ? 74 ? E8 */
				/* Search "No finale radio could be found.\n" - target is first sub call in this function */
			}

			/*
			*  CDirector::IsAnySurvivorInExitCheckpoint(CDirector *__hidden this)
			*/
			"CDirector::IsAnySurvivorInExitCheckpoint"
			{
				"library"	"server"
				"linux"		"@_ZNK9CDirector29IsAnySurvivorInExitCheckpointEv"
				"windows"	"\x55\x8B\x2A\x51\x8D\x2A\x2A\x50\x66\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8A\x2A\x2A\x83"
				/* 55 8B ? 51 8D ? ? 50 66 ? ? ? ? ? E8 ? ? ? ? 8A ? ? 83 */
				/* Search "tank_frustrated", below "HasAnySurvivorLeftSafeArea" call */
			}

			/*
			 * CDirector::AreAllSurvivorsInFinaleArea(CDirector *__hidden this)
			 */
			"CDirector::AreAllSurvivorsInFinaleArea"
			{
				"library"	"server"
				"linux"		"@_ZNK9CDirector27AreAllSurvivorsInFinaleAreaEv"
				"windows"	"\x55\x8B\x2A\x51\x8D\x2A\x2A\x50\x66\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x83\x2A\x2A\x8B"
				/* 55 8B ? 51 8D ? ? 50 66 ? ? ? ? ? E8 ? ? ? ? 83 ? ? 8B */
				/* Search "AreAllSurvivorsInFinaleArea" target call is below */
			}

			/*
			*  SurvivorBot::IsReachable(SurvivorBot *this, const Vector *)
			*/
			"SurvivorBot::IsReachable"
			{
				"library"	"server"
				"linux"		"@_ZNK11SurvivorBot11IsReachableERK6Vector"
				"windows"	"\x55\x8B\xEC\xD9\x05\x2A\x2A\x2A\x2A\x8B\x45\x08"
				/* 55 8B EC D9 05 ? ? ? ? 8B 45 08 */
				/* Search "Trying to use something to help us along" call somewhere above */
			}

			/*
			*  float NavAreaTravelDistance<ShortestPathCost>(Vector const&, Vector const&, ShortestPathCost &)
			*/
			"NavAreaTravelDistance"
			{
				"library"	"server"
				"linux"		"@_Z21NavAreaTravelDistanceI16ShortestPathCostEfRK6VectorS3_RT_"
				"windows"	"\x53\x8B\x2A\x83\x2A\x2A\x83\x2A\x2A\x83\x2A\x04\x55\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\xD9\x2A\x2A\x2A\x2A\x2A\x83"
				/* 53 8B ? 83 ? ? 83 ? ? 83 ? 04 55 8B ? ? 89 ? ? ? 8B ? D9 ? ? ? ? ? 83 */
				/* Search string: "Degenerate area %d". Xref this sub and goto .rdata VTable. Go ~6 entries down to "CNavArea::ComputeEarliestOccupyTimes". This sub calls our target function. */
			}

			// UNUSED: Using VScript Wrapper alternative. Args are difficult to follow for SDKCall.
			/*
			*  int NavAreaBuildPath<ShortestPathCost>(CNavArea *,CNavArea *,Vector const*,Vector const*,ShortestPathCost &,CNavArea **,float,int,bool)
			*/
			"NavAreaBuildPath"
			{
				"library"	"server"
				"linux"		"@_Z16NavAreaBuildPathI16ShortestPathCostEbP8CNavAreaS2_PK6VectorS5_RT_PS2_fib"
				"windows"	"\x53\x8B\x2A\x83\x2A\x08\x83\x2A\x2A\x83\x2A\x04\x55\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x83\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x56"
				/* 53 8B ? 83 ? 08 83 ? ? 83 ? 04 55 8B ? ? 89 ? ? ? 8B ? 83 ? ? A1 ? ? ? ? 33 ? 56 */
				/* Search "Arguments: ( area, area, flMaxPathLengt". Go into 3rd sub above or 2nd in HexRays. Match against Linux function. At the bottom is a call to target function, which should contain "& 0xF9 | 9" a little above the middle of the script in Hexrays */
			}

			/* const char *KeyValues::GetString(const char *keyName, const char *defaultValue) */
			"KeyValues::GetString"
			{
				"library"		"server"
				"linux"			"@_ZN9KeyValues9GetStringEPKcS1_"
				"windows"		"\x55\x8B\x2A\x81\x2A\x44\x02\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x53"
				/* 55 8B ? 81 ? 44 02 ? ? A1 ? ? ? ? 33 ? 89 ? ? 53 */
				/* Search: "WrongTeamMsg", call below is our function. */
			}

			/* CTerrorGameRules::GetNumChaptersForMissionAndMode(CTerrorGameRules *__hidden this) */
			"CTerrorGameRules::GetNumChaptersForMissionAndMode"
			{
				"library"		"server"
				"linux"			"@_ZN16CTerrorGameRules31GetNumChaptersForMissionAndModeEv"
				"windows"		"\x55\x8B\x2A\x81\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x83\x2A\x2A\x2A\x2A\x2A\x2A\x75\x2A\x33"
				/* 55 8B ? 81 ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 83 ? ? ? ? ? ? 75 ? 33 */
				/* Search: "Modes/%s". */
			}

			/* CDirector::GetGameModeBase(CDirector *__hidden this) */
			"CDirector::GetGameModeBase"
			{
				"library"		"server"
				"linux"			"@_ZN9CDirector15GetGameModeBaseEv"
				"windows"		"\xF7\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x56\x74\x2A\xBE\x2A\x2A\x2A\x2A\xEB\x2A\xA1\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x85\x2A\x75\x2A\xBE\x2A\x2A\x2A\x2A\x8B"
				/* F7 ? ? ? ? ? ? ? ? ? 56 74 ? BE ? ? ? ? EB ? A1 ? ? ? ? 8B ? ? 85 ? 75 ? BE ? ? ? ? 8B */
				/* Search: "NumberOfTeamDead" call is 2 functions below this. */
			}
			// =========================



			// ====================================================================================================
			// DETOURS
			// ====================================================================================================
			/*
			* ZombieManager::SpawnSpecial(ZombieClassType, Vector const&, QAngle const&)
			* Be careful, there are a few overrides for SpawnSpecial
			* Make sure the one you have has like 11 xrefs, 6 from CCommentaryZombieSpawner::InputSpawnZombie
			* To find, look for non-unique string "common_", has three refs, one ref will have strings for all classes, that's CCommentaryZombieSpawner::InputSpawnZombie
			*/
			"ZombieManager::SpawnSpecial"
			{
				"library"	"server"
				"linux"		"@_ZN13ZombieManager12SpawnSpecialE15ZombieClassTypeRK6VectorRK6QAngle"
				"windows"	"\x55\x8B\xEC\x53\x8B\x5D\x08\x8D\x43\xFF\x56"
				/* 55 8B EC 53 8B 5D 08 8D 43 FF 56 */
			}

			"ZombieManager::SpawnSpecial_Clone"
			{
				"library"	"server"
				"linux"		"@_ZN13ZombieManager12SpawnSpecialE15ZombieClassTypePK13TerrorNavAreaRK6QAngle"
				"windows"	"\x55\x8B\x2A\x81\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x56\x57\x8B\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x85\x2A\x0F\x84\x2A\x2A\x2A\x2A\xA1"
				/* 55 8B ? 81 ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 56 57 8B ? ? E8 ? ? ? ? 8B ? 85 ? 0F 84 ? ? ? ? A1 */
				/* Search: "Couldn't find a %s Spawn position in %d" */
			}

			/*
			 * ZombieManager::SpawnTank(Vector const&, QAngle const&)
			 *
			 * find by Navarea variant method and "Failed to find a tank spawn position i"
			 * OR
			 * To find, look for non-unique string "common_", has three refs, one ref will have strings for all classes, that's CCommentaryZombieSpawner::InputSpawnZombie
			 * SpawnTank will be called after string "tank"
			 */
			"ZombieManager::SpawnTank"
			{
				"library"	"server"
				"linux"		"@_ZN13ZombieManager9SpawnTankERK6VectorRK6QAngle"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x0D\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x85\xC0\x78\x2A\x8B\x0D\x2A\x2A\x2A\x2A\x39\x2A\x2A\x2A\x2A\x2A\x7C\x2A\x33\x2A\x5F"
				/* ? ? ? ? ? ? 8B 0D ? ? ? ? E8 ? ? ? ? 85 C0 78 ? 8B 0D ? ? ? ? 39 ? ? ? ? ? 7C ? 33 ? 5F */
			}

			/*
			 * ZombieManager::SpawnWitch(Vector const&, QAngle const&)
			 *
			 * find by Navarea variant method and "Failed to find a witch spawn position i"
			 * OR
			 * To find, look for non-unique string "common_", has three refs, one ref will have strings for all classes, that's CCommentaryZombieSpawner::InputSpawnZombie
			 * SpawnWitch will be called after string "witch"
			 */
			"ZombieManager::SpawnWitch"
			{
				"library"	"server"
				"linux"		"@_ZN13ZombieManager10SpawnWitchERK6VectorRK6QAngle"
				"windows"	"\x55\x8B\xEC\x8B\x0D\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x85\xC0\x78\x2A\x8B\x0D\x2A\x2A\x2A\x2A\x39\x81"
				/* 55 8B EC 8B 0D ? ? ? ? E8 ? ? ? ? 85 C0 78 */
			}

			/*
			* ZombieManager::SpawnWitchBride(Vector const&, QAngle const&)
			* Has three xref, one is CInfoZombieSpawn::SpawnZombie (shared with SpawnWitch above)
			* where SpawnWitch is the third call after string "bride", and SpawnWitchBride is the second call after "bride"
			*/
			"ZombieManager::SpawnWitchBride"
			{
				"library"	"server"
				"linux"		"@_ZN13ZombieManager15SpawnWitchBrideERK6VectorRK6QAngle"
				"windows"	"\x55\x8B\xEC\x8B\x0D\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x85\xC0\x75"
				/* 55 8B EC 8B 0D ? ? ? ? E8 ? ? ? ? 85 C0 75 */
			}

			/*
			 * CDirector::OnMobRushStart(void) - used by boomer and natural horde functions. Resets natural horde timer.
			 *
			 * find by String: "MobMinSize", its inlined in Windows
			 */
			"CDirector::OnMobRushStart"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector14OnMobRushStartEv"
				"windows"	"\x55\x8B\xEC\x83\xEC\x08\xA1\x2A\x2A\x2A\x2A\xD9\x40\x2C\x56\x57\x51"
				/* 55 8B EC 83 EC 08 A1 ? ? ? ? D9 40 2C 56 57 51 */
			}

			/*
			 * ZombieManager::SpawnITMob(int) - used for bile hordes, increases spawn count
			 *
			 * search for unique strings with "SpawnITMob"
			 */
			"ZombieManager::SpawnITMob"
			{
				"library"	"server"
				"linux"		"@_ZN13ZombieManager10SpawnITMobEi"
				"windows"	"\x55\x8B\xEC\xA1\x2A\x2A\x2A\x2A\xD9\x40\x0C\x56\x57"
				/* 55 8B EC A1 ? ? ? ? D9 40 0C 56 57 */
			}

			/*
			 * ZombieManager::SpawnMob(int) - used for natural/z_spawn
			 *		hordes, increases spawn count and calls horde music, etc
			 *
			 * search for unique strings with "SpawnMob"
			 */
			"ZombieManager::SpawnMob"
			{
				"library"	"server"
				"linux"		"@_ZN13ZombieManager8SpawnMobEi"
				"windows"	"\x55\x8B\xEC\xA1\x2A\x2A\x2A\x2A\xD9\x40\x0C\x83\xEC\x2A\x53\x56\x57"
				/* 55 8B EC A1 ? ? ? ? D9 40 0C 83 EC ? 53 56 57 */
			}

			/*
			 * CTerrorPlayer::OnEnterGhostState()
			 * almost unique string spawnmode_bar has three refs, one ref has strings "zombieClass" and "data"
			 */
			"CTerrorPlayer::OnEnterGhostState"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer17OnEnterGhostStateEv"
				"windows"	"\x55\x8B\xEC\x83\xEC\x08\x53\x56\x8B\xF1\x8B\x86\x2A\x2A\x2A\x2A\x8B"
				/* 55 8B EC 83 EC 08 53 56 8B F1 8B 86 ? ? ? ? 8B */
			}

			/*
			 * int CDirector::IsTeamFull(CTerrorGameRules *, int, int)
			 * Search: "is auto-joining infected". Called from here.
			 */
			"CDirector::IsTeamFull"
			{
				"library"		"server"
				"linux"			"@_ZNK9CDirector10IsTeamFullEiNS_15PlayerCountTypeE"
				"windows"		"\x55\x8B\x2A\x8B\x2A\x2A\x53\x56\x57\x8B\x2A\x2A\x50\x57\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B"
				/* 55 8B ? 8B ? ? 53 56 57 8B ? ? 50 57 8B ? E8 ? ? ? ? 8B */
			}

			/*
			 * CTerrorGameRules::ClearTeamScores(bool)
			 */
			"CTerrorGameRules::ClearTeamScores"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules15ClearTeamScoresEb"
				"windows"	"\x55\x8B\xEC\x51\x0F\x57\xC0\x53\x56\x57\x33\xDB\x8B"
				/* 55 8B EC 51 0F 57 C0 53 56 57 33 DB 8B */
			}

			/*
			 * CTerrorGameRules::SetCampaignScores(int,int)
			 * Search for unique string "singlechapter"
			 * -> has two xref from same function, CTerrorGameRules::IsSingleChapterMode()
			 * -> has two xref, one is CRestartGameIssue::ExecuteCommand() (exclude the other, CServerGameDLL::ServerHibernationUpdate(), which has string "FCVAR_NEVER_AS_STRING")
			 * -> CRestartGameIssue::ExecuteCommand() calls CDirectorVersusMode::VoteRestartVersusLevel() (fourth call..?)
			 * -> first call is CTerrorGameRules::SetCampaignScores()
			 * make sure to double check uniqueness when done
			 */
			"CTerrorGameRules::SetCampaignScores"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules17SetCampaignScoresEii"
				"windows"	"\x55\x8B\xEC\x56\x57\x8B\x7D\x08\x8B\xF1\x39\xBE\x2A\x2A\x2A\x2A\x74\x2A\xE8\x2A\x2A\x2A\x2A\x89\xBE\x2A\x2A\x2A\x2A\x8B"
				/* 55 8B EC 56 57 8B 7D 08 8B F1 39 BE ? ? ? ? 74 ? E8 ? ? ? ? 89 BE ? ? ? ? 8B */
			}

			/*
			 * CDirector::OnFirstSurvivorLeftSafeArea(CTerrorPlayer *)
			 *
			 * string "Allowing spawning - %s left safe area\n"
			 */
			"CDirector::OnFirstSurvivorLeftSafeArea"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector27OnFirstSurvivorLeftSafeAreaEP13CTerrorPlayer"
				"windows"	"\x55\x8B\x2A\x83\x2A\x2A\x53\x8B\x2A\x2A\x57\x8B\x2A\x8B"
				/* 55 8B ? 83 ? ? 53 8B ? ? 57 8B ? 8B */
				/* Search: "player_left_start_area" */
			}

			/*
			 * CDirector::OnForceSurvivorPositions()
			 */
			"CDirector::OnForceSurvivorPositions"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector24OnForceSurvivorPositionsERK10CUtlVectorIP13CTerrorPlayer10CUtlMemoryIS2_iEE"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x56\x33\x2A\x57\x68\x2A\x2A\x2A\x2A\x33"
				/* ? ? ? ? ? ? 53 56 33 ? 57 68 ? ? ? ? 33 */
				/* Search "ESCAPED: %s %s\n" bottom of function returns the call to target function. */
			}

			/*
			 * CDirector::OnReleaseSurvivorPositions(CUtlVector<CTerrorPlayer *, CUtlMemory<CTerrorPlayer *, int>> const&)
			 */
			"CDirector::OnReleaseSurvivorPositions"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector26OnReleaseSurvivorPositionsERK10CUtlVectorIP13CTerrorPlayer10CUtlMemoryIS2_iEE"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x56\x33\x2A\x8D\x2A\x2A\x57\x50\x89\x2A\x2A\x89\x2A\x2A\x89\x2A\x2A\x89\x2A\x2A\x89\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B"
				/* ? ? ? ? ? ? 56 33 ? 8D ? ? 57 50 89 ? ? 89 ? ? 89 ? ? 89 ? ? 89 ? ? E8 ? ? ? ? 8B */
				/* Search "ReleaseSurvivorPositions" bellow is target call. */
			}

			/*
			 * SpeakResponseConceptFromEntityIO(CBaseEntity *, CAI_Expresser *, inputdata_t)
			 */
			"SpeakResponseConceptFromEntityIO"
			{
				"library"	"server"
				"linux"		"@_Z32SpeakResponseConceptFromEntityIOP11CBaseEntityP13CAI_Expresser11inputdata_t"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x83\x2A\x2A\x2A\x8B\x2A\x2A\x8B\x2A\x2A\x89"
				/* ? ? ? ? ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 83 ? ? ? 8B ? ? 8B ? ? 89 */
				/* Search "faulty context k:v pair in entity io %s\n" */
			}

			/*
			 * CTerrorPlayer::GetCrouchTopSpeed(void)const
			 * an xref from GetRunTopSpeed
			 */
			"CTerrorPlayer::GetCrouchTopSpeed"
			{
				"library"	"server"
				"linux"		"@_ZNK13CTerrorPlayer17GetCrouchTopSpeedEv"
				"windows" 	"\x56\x8B\xF1\x80\x2A\x2A\x2A\x2A\x2A\x2A\x74\x2A\x5E\xE9\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x83\xF8"
				/* 56 8B F1 80 ? ? ? ? ? ? 74 ? 5E E9 ? ? ? ? E8 ? ? ? ? 83 F8 */
			}

			/*
			 * CTerrorPlayer::GetRunTopSpeed(void)const
			 *
			 * - Only references to float value 115.0 (00 00 E6 42) are in this func.
			 */
			"CTerrorPlayer::GetRunTopSpeed"
			{
				"library"	"server"
				"linux"		"@_ZNK13CTerrorPlayer14GetRunTopSpeedEv"
				"windows" 	"\x55\x8B\xEC\x83\xEC\x2A\x56\x8B\xF1\x8B\x06\x8B\x90\x2A\x2A\x2A\x2A\xFF\xD2\x84\xC0\x74\x0D\xA1\x2A\x2A\x2A\x2A\xD9\x40\x2A\x5E"
				/* 55 8B EC 83 EC ? 56 8B F1 8B 06 8B 90 ? ? ? ? FF D2 84 C0 74 0D A1 ? ? ? ? D9 40 ? 5E */
			}

			/*
			 * CTerrorPlayer::GetWalkTopSpeed(void)const
			 * an xref from GetRunTopSpeed
			 */
			"CTerrorPlayer::GetWalkTopSpeed"
			{
				"library"	"server"
				"linux"		"@_ZNK13CTerrorPlayer15GetWalkTopSpeedEv"
				"windows" 	"\x56\x8B\xF1\x80\x2A\x2A\x2A\x2A\x2A\x2A\x74\x2A\x5E\xE9\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x50\xE8"
				/* 56 8B F1 80 ? ? ? ? ? ? 74 ? 5E E9 ? ? ? ? E8 ? ? ? ? 50 E8 */
			}

			/*
			 * CDirector::GetScriptValue(const char*, int)
			 * Find CTerrorPlayer::OnRevived(), then look for string "SurvivorMaxIncapacitatedCount"
			 * If you look for string "No conversion from %s to int now\n" you will be one call too deep
			 */
			"CDirector::GetScriptValueInt"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector14GetScriptValueEPKci"
				"windows"	"\x55\x8B\xEC\x8B\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x74\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x08\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\xFF\xFF"
				/* 55 8B EC 8B ? ? ? ? ? 83 ? ? 83 ? ? 74 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 08 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? E8 ? ? FF FF */
			}

			/*
			 * CDirector::GetScriptValue(const char*, float)
			 * Called in CDirector::OnMobRushStart
			 */
			"CDirector::GetScriptValueFloat"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector14GetScriptValueEPKcf"
				"windows"	"\x55\x8B\xEC\x8B\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x74\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\xDE\xFF"
				/* 55 8B EC 8B ? ? ? ? ? 83 ? ? 83 ? ? 74 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? E8 ? ? DE FF */
				/* Search: "SpecialRespawnInterval" to find the call */
			}

			/*
			 * CDirector::GetScriptValue(char const*, Vector)
			 * Find with string "PreferredMobDirection"
			 */
			"CDirector::GetScriptValueVector"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector14GetScriptValueEPKc6Vector"
				"windows"	"\x55\x8B\xEC\x8B\x81\x2A\x2A\x2A\x2A\x83\xEC\x10\x83\xF8\xFF\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x45\x2A\x8B\x2A\x2A\x8B"
				/* 55 8B EC 8B 81 ? ? ? ? 83 EC 10 83 F8 FF ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 8B 45 ? 8B ? ? 8B */
			}

			/*
			 * CDirector::GetScriptValue(const char*, const char*, char*, int)
			 * unique string "OnChangeFinaleMusic", call right after it
			 */
			"CDirector::GetScriptValueString"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector14GetScriptValueEPKcS1_Pci"
				"windows"	"\x55\x8B\xEC\x8B\x81\x2A\x2A\x2A\x2A\x83\xEC\x2A\x56\x8B"
				/* 55 8B EC 8B 81 ? ? ? ? 83 EC ? 56 8B */
			}

			// The g_pScriptVM pointer
			"g_pScriptVM"
			{
				"library"	"server"
				"linux"		"@g_pScriptVM"
			}

			/*
			 *	 CTerrorGameRules::HasConfigurableDifficultySetting(void)
			 *
			 * - Look for string "hasdifficulty"
			 */
			"CTerrorGameRules::HasConfigurableDifficultySetting"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules32HasConfigurableDifficultySettingEv"
				"windows"	"\x8B\x0D\x2A\x2A\x2A\x2A\x85\xC9\x75\x1B\xE8\x2A\x2A\x2A\x2A\x84"
				/* 8B 0D ? ? ? ? 85 C9 75 1B E8 ? ? ? ? 84 */
			}

			/**
			 * Thanks to "Psyk0tik" from: https://github.com/Psykotikism/L4D1-2_Signatures
			 * CTerrorGameRules::IsGenericCooperativeMode()
			 *
			 * How to find on Windows:
			 * 1. Locate the "CTerrorGameRules::IsRealismMode" function.
			 * 2. One of the functions that calls "CTerrorGameRules::IsRealismMode" should be this function.
			 **/
			"CTerrorGameRules::IsGenericCooperativeMode"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules24IsGenericCooperativeModeEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x75\x2A\xE8\x2A\x2A\x2A\x2A\x84\xC0\x75\x2A\x33\xC0\xC3\xB8\x01\x00\x00\x00\xC3\xCC\xCC\xCC\xCC\xCC\x8B"
				/* ? ? ? ? ? ? ? 75 ? E8 ? ? ? ? 84 C0 75 ? 33 C0 C3 B8 01 00 00 00 C3 CC CC CC CC CC 8B */
			}

			/**
			 * Thanks to "Psyk0tik" from: https://github.com/Psykotikism/L4D1-2_Signatures
			 * CTerrorGameRules::IsRealismMode()
			 *
			 * How to find on Windows:
			 * 1. Search for the "realism" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTerrorGameRules::IsRealismMode"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules13IsRealismModeEv"
				// Windows now matching with dynamically generated address to make the signature future proof.
				// "windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x85\x2A\x75\x2A\x32\x2A\xC3\xF7\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x74\x2A\xB8\x2A\x2A\x2A\x2A\xEB\x2A\xA1\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x85\x2A\x75\x2A\xB8\x2A\x2A\x2A\x2A\x8B\x2A\x50\x8B\x2A\x2A\xFF\x2A\x85\x2A\x74\x2A\x2A\x64"
				/* ? ? ? ? ? ? 85 ? 75 ? 32 ? C3 F7 ? ? ? ? ? ? ? ? ? 74 ? B8 ? ? ? ? EB ? A1 ? ? ? ? 8B ? ? 85 ? 75 ? B8 ? ? ? ? 8B ? 50 8B ? ? FF ? 85 ? 74 ? ? 64 */
			}
			"Realism_StrFind"
			{
				"library"		"server"
				"windows"		"realism"
				/* Search for the literal string to then reverse bytes and search for that address. */
			}

			/**
			 * Thanks to "Psyk0tik" from: https://github.com/Psykotikism/L4D1-2_Signatures
			 * CTerrorPlayer::OnFalling()
			 *
			 * How to find on Windows:
			 * 1. Search for the "PlayerZombie.Fall" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTerrorPlayer::OnFalling"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer9OnFallingEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x53\x56\x57\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x83\x2A\x2A\x0F"
				/* ? ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 53 56 57 8B ? E8 ? ? ? ? 83 ? ? 0F */
			}

			/* CTerrorPlayer::EstimateFallingDamage(CTerrorPlayer *this) */
			"CTerrorPlayer::EstimateFallingDamage"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer21EstimateFallingDamageEv"
				"windows"	"\x53\x8B\x2A\x83\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x55\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x81\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x56\x57\x8B\x2A\x8B\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x84"
				/* 53 8B ? 83 ? ? 83 ? ? 83 ? ? 55 8B ? ? 89 ? ? ? 8B ? 81 ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 56 57 8B ? 8B ? 8B ? ? ? ? ? ? ? 84 */
				/* Search "Too many traces, %f damage, %d iterations\n" */
			}

			/**
			 * Thanks to "Psyk0tik" from: https://github.com/Psykotikism/L4D1-2_Signatures
			 * CDeathFallCamera::Enable(CBasePlayer*)
			 *
			 * How to find on Windows:
			 * 1. Search for the "SurvivorStandingOnCar" string.
			 * 2. The string can only be found in "CTerrorPlayer::OnGroundChanged".
			 * 3. Look for the "point_deathfall_camera" string in "CTerrorPlayer::OnGroundChanged".
			 * 4. The first function call after that string's second reference should be "CBasePlayer::ClearZoomOwner".
			 * 5. One of the functions that calls "CBasePlayer::ClearZoomOwner" should be this function.
			 **/
			"CDeathFallCamera::Enable"
			{
				"library"	"server"
				"linux"		"@_ZN16CDeathFallCamera6EnableEP11CBasePlayer"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x57\x8B\x2A\x8B\x2A\x89\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x85"
				/* ? ? ? ? ? ? ? ? 57 8B ? 8B ? 89 ? ? E8 ? ? ? ? 85 */
			}

			/* CTerrorPlayer::Cough(CTerrorPlayer *this, CBasePlayer *) */
			"CTerrorPlayer::Cough"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer5CoughEP11CBasePlayer"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x50\xE8\x2A\x2A\x2A\x2A\x83\x2A\x2A\x84\x2A\x0F\x84\x2A\x2A\x2A\x2A\x80\x2A\x2A\x2A\x2A\x2A\x2A\x57"
				/* ? ? ? ? ? ? ? E8 ? ? ? ? 50 E8 ? ? ? ? 83 ? ? 84 ? 0F 84 ? ? ? ? 80 ? ? ? ? ? ? 57 */
				/* Search "#L4D_idle_spectator" xref to VTable, target is function above. */
			}

			/**
			 *  Witch::SetHarasser(Witch *this, CBaseEntity *)
			 **/
			"Witch::SetHarasser"
			{
				"library"	"server"
				"linux"		"@_ZN5Witch11SetHarasserEP11CBaseEntity"
				"windows"	"\x55\x8B\x2A\x51\x53\x8B\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x57\x83\x2A\xFF"
				/* 55 8B ? 51 53 8B ? 8B ? ? ? ? ? 57 83 ? FF */
				/* Search: "witchid" and compare to linux, one with strings only related to the event and without other random strings */
			}

			/**
			 * Thanks to "Psyk0tik" from: https://github.com/Psykotikism/L4D1-2_Signatures
			 * Tank::EnterStasis()
			 *
			 * How to find on Windows:
			 * 1. Search for any of the following strings (they can each only be found in one function):
			 * - "Tank offer: Starting the lottery\n"
			 * - "Tank offer: Going to the only PZ\n"
			 * - "Tank offer: making a bot, and giving him to nobody\n"
			 * 2. This function should be referenced by a function that is two function calls above the "Tank offer: Starting the lottery\n" string.
			 * 3. This function should be the last function call in that function.
			 **/
			"Tank::EnterStasis"
			{
				"library"	"server"
				"linux"		"@_ZN4Tank11EnterStasisEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8D\xB7\x2A\x2A\x2A\x2A\x74\x2A\x8B\x86\x2A\x2A\x2A\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8D\x8E\x2A\x2A\x2A\x2A\x56\xFF\x2A\xC6\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x6A"
				/* ? ? ? ? ? ? ? ? ? ? ? 8D B7 ? ? ? ? 74 ? 8B 86 ? ? ? ? 8B 90 ? ? ? ? 8D 8E ? ? ? ? 56 FF ? C6 ? ? 8B ? 8B 90 ? ? ? ? 6A */
			}

			/**
			 * Thanks to "Psyk0tik" from: https://github.com/Psykotikism/L4D1-2_Signatures
			 * Tank::LeaveStasis()
			 *
			 * How to find on Windows:
			 * 1. Search for the "Tank committing suicide at %f %f %f\n" string.
			 * 2. There should be two function calls above the string.
			 * 2. The first function call should be this function.
			 **/
			"Tank::LeaveStasis"
			{
				"library"	"server"
				"linux"		"@_ZN4Tank11LeaveStasisEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8D\xB7\x2A\x2A\x2A\x2A\x74\x2A\x8B\x86\x2A\x2A\x2A\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8D\x8E\x2A\x2A\x2A\x2A\x56\xFF\x2A\xC6\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B"
				/* ? ? ? ? ? ? ? ? ? ? ? 8D B7 ? ? ? ? 74 ? 8B 86 ? ? ? ? 8B 90 ? ? ? ? 8D 8E ? ? ? ? 56 FF ? C6 ? ? 8B ? 8B 90 ? ? ? ? 8B */
			}

			/**
			 * Thanks to "Psyk0tik" from: https://github.com/Psykotikism/L4D1-2_Signatures
			 * CTankClaw::SweepFist(Vector const&, Vector const&)
			 *
			 * How to find on Windows:
			 * 1a. Search for any of the following strings (they can each only be found in this function):
			 * - "rhand"
			 * - "lhand"
			 * - "ValveBiped.Bip01_L_Hand"
			 * 1b. Search for the "ValveBiped.Bip01_R_Hand" string.
			 * 2b. One of the functions that references that string should be this function.
			 **/
			"CTankClaw::DoSwing"
			{
				"library"	"server"
				"linux"		"@_ZN9CTankClaw7DoSwingEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x56\x89\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x85"
						/* ? ? ? ? ? ? 56 89 ? ? E8 ? ? ? ? 8B ? 85 */
			}

			/**
			 * Thanks to "Psyk0tik" from: https://github.com/Psykotikism/L4D1-2_Signatures
			 * CTankClaw::GroundPound()
			 *
			 * How to find on Windows:
			 * 1. Locate the "CTankClaw::SweepFist" function.
			 * 2. Click on the second to last function call to go to "CTerrorWeapon::MarkAsHit".
			 * 3. This function calls "CTerrorWeapon::MarkAsHit" twice.
			 * 4. To pinpoint the right function, look for the one that sets multiple variables to "0".
			 **/
			"CTankClaw::GroundPound"
			{
				"library"	"server"
				"linux"		"@_ZN9CTankClaw11GroundPoundEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x55\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x81\xEC\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x56\x57\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x89"
						/* ? ? ? ? ? ? 83 ? ? 83 ? ? 55 8B ? ? 89 ? ? ? 8B ? 81 EC ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 56 57 8B ? E8 ? ? ? ? 8B ? 89 */
			}

			/**
			 * Thanks to "Psyk0tik" from: https://github.com/Psykotikism/L4D1-2_Signatures
			 * CTankClaw::OnPlayerHit(CTerrorPlayer*, bool)
			 *
			 * How to find on Windows:
			 * 1a. Search for the "PlayerGroundPoundedByTank" string.
			 * 2a. The string can only be found in this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. In IDA Pro, go to the ".rdata" section of the Windows binary.
			 * 3b. Search for "CTankClaw::`vftable'" to jump to the "CTankClaw" vtable.
			 * 4b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 5b. Look for the target function in the Windows binary.
			 **/
			"CTankClaw::OnPlayerHit"
			{
				"library"	"server"
				"linux"		"@_ZN9CTankClaw11OnPlayerHitEP13CTerrorPlayerb"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x53\x56\x8B\x2A\x2A\x57\x8B\x2A\x89\x2A\x2A\xE8"
						/* ? ? ? ? ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 53 56 8B ? ? 57 8B ? 89 ? ? E8 */
			}

			/**
			 * Thanks to "Psyk0tik" from: https://github.com/Psykotikism/L4D1-2_Signatures
			 * CTankRock::Detonate()
			 *
			 * How to find on Windows:
			 * 1a. Search for the "tank_rock_throw_impact_stump" string.
			 * 2a. The string can only be found in this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. In IDA Pro, go to the ".rdata" section of the Windows binary.
			 * 3b. Search for "CTankRock::`vftable'" to jump to the "CTankRock" vtable.
			 * 4b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 5b. Look for the target function in the Windows binary.
			 **/
			"CTankRock::Detonate"
			{
				"library"	"server"
				"linux"		"@_ZN9CTankRock8DetonateEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x56\x8B\x2A\x80\xBE\x2A\x2A\x2A\x2A\x2A\x57\x0F\x84\x2A\x2A\x2A\x2A\xA1"
						/* ? ? ? ? ? ? 53 56 8B ? 80 BE ? ? ? ? ? 57 0F 84 ? ? ? ? A1 */
			}

			/**
			 * Thanks to "Psyk0tik" from: https://github.com/Psykotikism/L4D1-2_Signatures
			 * CTankRock::OnRelease(Vector const&, QAngle const&, Vector const&, Vector const&)
			 *
			 * How to find on Windows:
			 * 1. Search for the "HulkZombie.Throw.FlyLoop" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTankRock::OnRelease"
			{
				"library"	"server"
				"linux"		"@_ZN9CTankRock9OnReleaseERK6VectorRK6QAngleS2_S2_"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x57\xC6\x86\x2A\x2A\x2A\x2A\x2A\xC7"
						/* ? ? ? ? ? ? 57 C6 86 ? ? ? ? ? C7 */
			}

			/*
			 * CTerrorGameRules::GetSurvivorSet(void)
			 *
			 * - string "survivor_set"
			 */
			"CTerrorGameRules::GetSurvivorSet"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules14GetSurvivorSetEv"
				"windows" 	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x01\x8B\x50\x2A\x53\x56\xBB"
				/* ? ? ? ? ? ? ? ? ? ? 8B 01 8B 50 ? 53 56 BB */ // Wildcarded for 3rd party plugins
				/* 55 8B EC 51 8B 0D ? ? ? ? 8B 01 8B 50 ? 53 */
			}

			/*
			 * CTerrorGameRules::FastGetSurvivorSet(void)
			 *
			 * - Should be 2 calls after "DistToMechanic" in CTerrorPlayer::ModifyOrAppendCriteria
			 */
			"CTerrorGameRules::FastGetSurvivorSet"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules18FastGetSurvivorSetEv"
				"windows" 	"\xA1\x2A\x2A\x2A\x2A\x85\xC0\x75\x0A\xE8"
				/* A1 ? ? ? ? 85 C0 75 0A E8 */
			}

			/*
			 *	CDirectorVersusMode::GetMissionVersusBossSpawning(float&, float&, float&, float&)
			 *
			 * - string "versus_boss_spawning" hits in 2 functions: This short func and the much longer InitVersusBossSpawning
			 */
			"CDirectorVersusMode::GetMissionVersusBossSpawning"
			{
				"library"	"server"
				"linux"		"@_ZN19CDirectorVersusMode28GetMissionVersusBossSpawningERfS0_S0_S0_Rb"
				"windows"	"\x55\x8B\xEC\x6A\x00\xE8\x2A\x2A\x2A\x2A\x83\xC4\x04\x85"
				/* 55 8B EC 6A 00 E8 ? ? ? ? 83 C4 04 85 */
			}

			/*
			 * ZombieManager::ReplaceTank(CTerrorPlayer *, CTerrorPlayer *)
			 *
			 * for finding: in CDirector::UpdateTankSpawns, easily findable in graph view from ReplaceWithBot
			 */
			"ZombieManager::ReplaceTank"
			{
				"library"	"server"
				"linux"		"@_ZN13ZombieManager11ReplaceTankEP13CTerrorPlayerS1_"
				"windows" 	"\x55\x8B\xEC\x83\xEC\x2A\x53\x56\x8B\x75\x2A\x8B\x06\x8B\x90\x2A\x2A\x2A\x2A\x57\x8B\xF9\x8B\xCE\xFF\xD2\x84\xC0\x0F"
				/* 55 8B EC 83 EC ? 53 56 8B 75 ? 8B 06 8B 90 ? ? ? ? 57 8B F9 8B CE FF D2 84 C0 0F */
			}

			/*
			 * CDirector::TryOfferingTankBot(void)
			 * unique string "Tank offer: Starting the lottery\n"
			 */
			"CDirector::TryOfferingTankBot"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector18TryOfferingTankBotEP11CBaseEntityb"
				"windows"	"\x55\x8B\xEC\x51\x83\x7D\x08\x00\x56\x8B\xF1\x89"
				/* 55 8B EC 51 83 7D 08 00 56 8B F1 89 */
			}

			/*
			 * CThrow::ActivateAbililty()
			 *		Start a tank rock throw
			 *
			 * - "HulkZombie.Throw.Fail" has 2 refs in this function. Should be easy to find.
			 */
			"CThrow::ActivateAbililty"
			{
				"library"	"server"
				"linux"		"@_ZN6CThrow15ActivateAbilityEv"
				"windows"	"\x55\x8B\xEC\x51\x53\x8B\xD9\x8B\x83\x2A\x2A\x2A\x2A\x83"
				/* 55 8B EC 51 53 8B D9 8B 83 ? ? ? ? 83 */
			}

			/*
			 * int CBaseAnimating::SelectWeightedSequence(int Activity)
			 *
			 * - Called at the end of CTerrorPlayer::SelectWeightedSequence() (found via string "Hulk_RunAttack1_Gesture")
			 * NOTE - WARNING - This function should probably be hooked using vtable methods!!!!!!!! DEPRECATE
			 */
			"CBaseAnimating::SelectWeightedSequence"
			{
				"library"	"server"
				"linux"		"@_ZN14CBaseAnimating22SelectWeightedSequenceE8Activity"
				"windows"	"\x55\x8B\xEC\x56\x8B\xF1\x83\xBE\x2A\x2A\x2A\x2A\x00\x57\x8B\xBE"
				/* 55 8B EC 56 8B F1 83 BE ? ? ? ? 00 57 8B BE */
			}

			/*
			 * CTerrorPlayer::DoAnimationEvent(PlayerAnimEvent_t, int)
			 */
			"CTerrorPlayer::DoAnimationEvent"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer16DoAnimationEventE17PlayerAnimEvent_ti"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x57\x8B\x2A\x83\x2A\x2A\x74\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x2A\x53"
				/* ? ? ? ? ? ? ? 57 8B ? 83 ? ? 74 ? 8B ? ? ? ? ? 8B ? 8B ? ? 53 */
				/* Search "NULL Ent in GiveNamedItem!\n" (function with "weapon_shield" inside) - xref to last VTable call, couple entries down */
			}

			/* Thanks to "Lux" for the signature */
			"CTerrorMeleeWeapon::GetDamageForVictim"
			{
				"library"		"server"
				"linux"			"@_ZN18CTerrorMeleeWeapon18GetDamageForVictimEP11CBaseEntity"
				"windows"		"\x2A\x2A\x2A\x2A\x2A\x2A\x17\x00\x00\x56\x57"
				/* ? ? ? ? ? ? 17 00 00 56 57 */
				/* Search "MeleeSlashSplatter" - the function with "MeleeClubSplatter" below, and "bloodslash" even lower down. */
			}

			/*
			 * CTerrorMeleeWeapon::StartMeleeSwing(CTerrorPlayer *, bool)
			 *
			 * find "melee attack failed - !IsWeaponVisible" in CTerrorWeapon::PrimaryAttack and look for a call (being passed ptr and float) followed by some sse xmm0 calls.
			 */
			"CTerrorMeleeWeapon::StartMeleeSwing"
			{
				"library"	"server"
				"linux"		"@_ZN18CTerrorMeleeWeapon15StartMeleeSwingEP13CTerrorPlayerb"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x8B\xF1\x8B\x86\x2A\x2A\x2A\x2A\x50\xB9\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B"
				/* ? ? ? ? ? 8B F1 8B 86 ? ? ? ? 50 B9 ? ? ? ? E8 ? ? ? ? 8B */ // Wildcarded for 3rd party plugins
				/* 55 8B EC 53 56 8B F1 8B 86 ? ? ? ? 50 B9 */
			}

			/*
			 * CDirectorScriptedEventManager::SendInRescueVehicle(void)
			 *
			 * find by String "FinaleEscapeStarted"
			 */
			"CDirectorScriptedEventManager::SendInRescueVehicle"
			{
				"library"	"server"
				"linux"		"@_ZN29CDirectorScriptedEventManager19SendInRescueVehicleEv"
				"windows"	"\x55\x8B\xEC\x83\xEC\x18\x56\x68\x2A\x2A\x2A\x2A\x8B\xF1"
				/* 55 8B EC 83 EC 18 56 68 ? ? ? ? 8B F1 */
			}

			/*
			 * CDirectorScriptedEventManager::ChangeFinaleStage(CDirectorScriptedEventManager::FinaleStageType,char const*)
			 *
			 * find by String "CHANGEFINALESTAGEOVERRIDE: %s\n"
			 */
			"CDirectorScriptedEventManager::ChangeFinaleStage"
			{
				"library"	"server"
				"linux"		"@_ZN29CDirectorScriptedEventManager17ChangeFinaleStageENS_18ScriptedEventStageEPKc"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x53\x8B\x2A\x2A\x56\x8B\x2A\x2A\x57\x53\x68"
				/* ? ? ? ? ? ? ? ? ? ? ? ? ? ? 33 ? 89 ? ? 53 8B ? ? 56 8B ? ? 57 53 68 */ // Wildcarded for 3rd party plugins
				/* 55 8B ? 81 ? ? ? ? ? ? ? ? ? ? 33 ? 89 ? ? 53 8B ? ? 56 8B ? ? 57 53 68 */
			}

			/*
			 * CDirectorVersusMode::EndVersusModeRound(bool)
			 * Updates scores using a bunch of CTerrorGameRules calls and triggers the fullscreen_vs_scoreboard viewport panel
			 *
			 * find by String "fullscreen_vs_scoreboard", and look for a func which also creates a "scores" kv and sets values for "t1", "t2", "c1", "c2", and "tiebreak"
			 */
			"CDirectorVersusMode::EndVersusModeRound"
			{
				"library"	"server"
				"linux"		"@_ZN19CDirectorVersusMode18EndVersusModeRoundEb"
				"windows"	"\x55\x8B\xEC\x83\xEC\x2A\x57\x8B\xF9\xE8\x2A\x2A\x2A\x2A\x84\xC0\x0F\x84"
				/* 55 8B EC 83 EC ? 57 8B F9 E8 ? ? ? ? 84 C0 0F 84 */
			}

			/*
			 * void CTerrorPlayer::OnLedgeGrabbed(CTerrorPlayer *this, const Vector *)
			 * Search: "%s grabs a ledge - last standing at %s."
			 */
			"CTerrorPlayer::OnLedgeGrabbed"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer14OnLedgeGrabbedERK6Vector"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x53\x56\x8B\x2A\x8B\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x57\x2A\x2A\x84\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B"
				/* ? ? ? ? ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 53 56 8B ? 8B ? 8B ? ? ? ? ? 57 ? ? 84 ? 0F 84 ? ? ? ? 8B */
			}

			/*
			* CTerrorPlayer::OnRevived(void)
			*
			* ->Search for string "revive_success", then open vtables window. Should be the 5th member.
			* Left4Downtown2 patches this function, which will prevent Sourcemod from finding it
			* That is why the first six bytes are wild cards (five bytes for detour + nop fill the remaining bytes of the instructions)
			*/
			"CTerrorPlayer::OnRevived"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer9OnRevivedEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x56\x8B\xF1\x8B\x06\x8B\x90\x2A\x2A\x2A\x2A\x57\xFF\xD2\x84\xC0\x0F\x84\x2A\x2A\x2A\x2A\x8B\xCE"
				/* ? ? ? ? ? ? 53 56 8B F1 8B 06 8B 90 ? ? ? ? 57 FF D2 84 C0 0F 84 ? ? ? ? 8B CE */
			}

			/*
			 * CTerrorPlayer::OnStaggered(CBaseEntity *, Vector const*) - used by L4D2 on Survivors, causes staggering (e.g. Charger Impact nearby)
			 *
			 * - string "PlayerShoved" has 3 refs, the one furthest into a function should be this one.
			 */
			"CTerrorPlayer::OnStaggered"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer11OnStaggeredEP11CBaseEntityPK6Vector"
				"windows" 	"\x2A\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x55\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x83\x2A\x2A\x56\x57\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x0F\x85\x2A\x2A\x2A\x2A\x8B\x2A\x8B"
				/* ? ? ? ? ? ? 83 ? ? 83 ? ? 55 8B ? ? 89 ? ? ? 8B ? 83 ? ? 56 57 8B ? E8 ? ? ? ? 84 ? 0F 85 ? ? ? ? 8B ? 8B
				 * Using a long local jump as the unique portion (last few bytes of sig)
				 */
			}

			/*
			 *  CTerrorWeapon::OnSwingStart(CTerrorWeapon *this)
			 */
			"CTerrorWeapon::OnSwingStart"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorWeapon12OnSwingStartEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x56\x57\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x85\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x8B"
				/* ? ? ? ? ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 56 57 8B ? E8 ? ? ? ? 8B ? 85 ? 0F 84 ? ? ? ? 8B ? 8B ? ? ? ? ? 8B */
				/* Search: "Weapon.Swing" */
			}

			/*
			 * CTerrorPlayer::OnShovedBySurvivor(CTerrorPlayer*, Vector const&) - used by L4D2 on Special Infected (got melee'd)
			 * unique string "jockey_ride" in CTerrorPlayer::OnLeptOnSurvivor(), look up for "JockeyZombie.Ride", look up for var_14, CTerrorPlayer::OnShovedBySurvivor is call after that
			 */
			"CTerrorPlayer::OnShovedBySurvivor"
			{
				"library"	"server"
				"linux" 	"@_ZN13CTerrorPlayer18OnShovedBySurvivorEPS_RK6Vector"
				"windows" 	"\x55\x8B\xEC\x81\xEC\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\xC5\x89\x45\xFC\x53\x8B\x5D\x2A\x56\x57\x8B\x7D\x2A\x8B\xF1"
				/* 55 8B EC 81 EC ? ? ? ? A1 ? ? ? ? 33 C5 89 45 FC 53 8B 5D ? 56 57 8B 7D ? 8B F1 */
			}

			/*
			* CTerrorWeapon::OnHit(CGameTrace &, Vector const&, bool)
			*/
			"CTerrorWeapon::OnHit"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorWeapon5OnHitER10CGameTraceRK6Vectorb"
				"windows"	"\x55\x8B\xEC\x81\xEC\xB0\x00\x00\x00\x80\x7D\x10\x00"
				/* 55 8B EC 81 EC B0 00 00 00 80 7D 10 00 */
			}

			/*
			* CTerrorPlayer::OnShovedByPounceLanding(CTerrorPlayer*)
			*/
			"CTerrorPlayer::OnShovedByPounceLanding"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer23OnShovedByPounceLandingEPS_b"
				"windows"	"\x55\x8B\x2A\x83\x2A\x2A\x56\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x0F\x85\x2A\x2A\x2A\x2A\x57\x8B"
				/* 55 8B ? 83 ? ? 56 8B ? E8 ? ? ? ? 84 ? 0F 85 ? ? ? ? 57 8B */
				/* Search: "pounced on %s, %d damage interrupts".
				 * Several calls from here to target function, visual match with nix code.
				 */
			}

			/*
			* CInferno::Spread(Vector const&)
			*/
			"CInferno::Spread"
			{
				"library"	"server"
				"linux"		"@_ZN8CInferno6SpreadERK6Vector"
				"windows" 	"\x2A\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x55\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x81\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x8B\x2A\x2A\x56\x57\x8B\x2A\xF3\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x0F\x2F"
				/* 53 8B ? 83 ? ? 83 ? ? 83 ? ? 55 8B ? ? 89 ? ? ? 8B ? 81 ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 8B ? ? 56 57 8B ? F3 ? ? ? ? ? ? ? 0F 2F */
				/* Search: "CInferno::InfernoThink (spread)" bit below is target call. */
			}

			/*
			* SurvivorBot::UseHealingItems(Action<SurvivorBot> *)
			* Called by the game when deciding whether the bots should use any healing items
			* unique string "Trying to heal a friend"
			*/
			"SurvivorBot::UseHealingItems"
			{
				"library"	"server"
				"linux"		"@_ZN11SurvivorBot15UseHealingItemsEP6ActionIS_E"
				"windows"	"\x55\x8B\x2A\x83\x2A\x2A\x53\x56\x57\x8B\x2A\x8D\x2A\x2A\x2A\x2A\x2A\x8D\x2A\x2A\x2A\x2A\x2A\xE8"
				/* ? ? ? ? ? ? 53 56 57 8B ? 8D ? ? ? ? ? 8D ? ? ? ? ? E8 */
				/* Search "Trying to heal a friend" */
			}

			/*
			* SurvivorBot::FindScavengeItem(float)
			* Called by the game when deciding what items a bot should attempt to pick up
			* Despite name, has nothing to do with scavenge game mode
			* SurvivorBot::ScavengeNearbyItems(Action<SurvivorBot>*) has almost unique string "Scavenging something"
			* FindScavengeItem(float) is called with 420.0 (0x43D20000) as its argument
			*/
			"SurvivorBot::FindScavengeItem"
			{
				"library"	"server"
				"linux"		"@_ZNK11SurvivorBot16FindScavengeItemEf"
				"windows"	"\x55\x8B\xEC\x81\xEC\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\xC5\x89\x45\xFC\x53\x56\x57\x8B\xF9\x8B\x97\x2A\x2A\x2A\x2A\x8D\x85"
				/* 55 8B EC 81 EC ? ? ? ? A1 ? ? ? ? 33 C5 89 45 FC 53 56 57 8B F9 8B 97 ? ? ? ? 8D 85 */
			}

			/*
			 * CInsectSwarm::CanHarm(CInsectSwarm *this, CBaseEntity *)
			 */
			"CInsectSwarm::CanHarm"
			{
				"library"	"server"
				"linux"		"@_ZNK12CInsectSwarm7CanHarmEP11CBaseEntity"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x84\x2A\x74\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x50\xE8\x2A\x2A\x2A\x2A\x83\x2A\x2A\x5E\x5D"
				/* ? ? ? ? ? ? ? 8B ? 8B ? ? ? ? ? 8B ? FF ? 84 ? 74 ? 8B ? E8 ? ? ? ? 50 E8 ? ? ? ? 83 ? ? 5E 5D */
				/* Search: "spitter_areaofdenial". Few entries down in vtable. */
			}

			/* CBreakableProp::Break(CBreakableProp *this, CBaseEntity *a2, const CTakeDamageInfo *a3) */
			"CBreakableProp::Break"
			{
				"library"		"server"
				"linux"			"@_ZN14CBreakableProp5BreakEP11CBaseEntityRK15CTakeDamageInfo"
				"windows"		"\x55\x8B\x2A\x81\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x8B\x2A\x2A\x53\x8B\x2A\x2A\x56\x8B\x2A\x8B\x2A\x8B\x2A\x2A\x89"
				/* 55 8B ? 81 ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 8B ? ? 53 8B ? ? 56 8B ? 8B ? 8B ? ? 89 */
				/* Search: "Fire prop detonated %.0f,%.0f,%.0f.  Breaker:%s. Attacker:%s.\n" */
			}

			/* CGasCan::Event_Killed(CGasCan *this, const CTakeDamageInfo *) */
			"CGasCan::Event_Killed"
			{
				"library"		"server"
				"linux"			"@_ZN7CGasCan12Event_KilledERK15CTakeDamageInfo"
				"windows"		"\x55\x8B\x2A\x81\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x53\x8B\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x56\x8B\x2A\x2A\xC1"
				/* 55 8B ? 81 ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 53 8B ? 8B ? ? ? ? ? 56 8B ? ? C1 */
				/* Search: "scavenge_gas_can_destroyed" */
			}

			/*
			 *  CGasCan::ShouldStartAction(int, int, CTerrorPlayer *, CPointPropUseTarget *)
			 */
			"CGasCan::ShouldStartAction"
			{
				"library"	"server"
				"linux"		"@_ZN7CGasCan17ShouldStartActionEN17CBaseBackpackItem22BackpackItemActionTypeEP13CTerrorPlayerP11CBaseEntity"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x57\x8B\x2A\x85\x2A\x74\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x75"
				/* ? ? ? ? ? ? ? 57 8B ? 85 ? 74 ? 8B ? E8 ? ? ? ? 84 ? 75 */
				/* Search: "gascan_pour_blocked" */
			}

			/* CGasCan::OnActionComplete(CGasCan *this, CTerrorPlayer *, CBaseEntity *) */
			"CGasCan::OnActionComplete"
			{
				"library"		"server"
				"linux"			"@_ZN7CGasCan16OnActionCompleteEP13CTerrorPlayerP11CBaseEntity"
				"windows"		"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x8B\x2A\x2A\x53\x8B\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x83"
				/* ? ? ? ? ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 8B ? ? 53 8B ? 8B ? ? ? ? ? 83 */
				/* Search: "gascan_pour_completed" */
			}

			/**
			 * Thanks to "Psyk0tik" from: https://github.com/Psykotikism/Mutant_Tanks
			 * CBaseBackpackItem::StartAction(CBaseBackpackItem::BackpackItemActionType, CBaseBackpackItem::BackpackItemActionTrigger)
			 *
			 * Note: Used for detouring the function.
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. In IDA Pro, go to the ".rdata" section of the Windows binary.
			 * 3. Search for "CBaseBackpackItem::`vftable'" to jump to the "CBaseBackpackItem" vtable.
			 * 4. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 5. Look for the target function in the Windows binary.
			 **/
			"CBaseBackpackItem::StartAction"
			{
				"library"	"server"
				"linux"		"@_ZN17CBaseBackpackItem11StartActionENS_22BackpackItemActionTypeENS_25BackpackItemActionTriggerE"
				"mac"		"@_ZN17CBaseBackpackItem11StartActionENS_22BackpackItemActionTypeENS_25BackpackItemActionTriggerE"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x85\x2A\x75\x2A\x5F\x32\x2A\x5E\x8B"
				/* ? ? ? ? ? ? 8B ? E8 ? ? ? ? 8B ? 85 ? 75 ? 5F 32 ? 5E 8B */
			}

			/* cdecl BossZombiePlayerBot::ChooseVictim(BossZombiePlayerBot *this, CTerrorPlayer *, char, CBaseCombatCharacter *) */
			"BossZombiePlayerBot::ChooseVictim"
			{
				"library"		"server"
				"linux"			"@_ZN19BossZombiePlayerBot12ChooseVictimEP13CTerrorPlayeriP20CBaseCombatCharacter"
				"windows"		"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x2A\x53\x8B\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x56"
				/* ? ? ? ? ? ? ? ? ? ? ? 83 ? ? ? 53 8B ? 8B ? ? ? ? ? 8B ? ? ? ? ? 56 */ // Wildcarded for 3rd party plugins
				/* 55 8B ? 83 ? ? ? ? ? ? ? 83 ? ? ? 53 8B ? 8B ? ? ? ? ? 8B */
				/* Search: "switching to mobile victim" */
			}

			"CServerGameDLL::ServerHibernationUpdate"
			{
				"library" 	"server"
				"linux"		"@_ZN14CServerGameDLL23ServerHibernationUpdateEb"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x53\x56\x33\x2A\x8B\x2A\x88\x2A\x2A\x3A"
				/* ? ? ? ? ? ? 83 ? ? 53 56 33 ? 8B ? 88 ? ? 3A */
				/* Search: "%s_%s_%d%s" and xref to vtable, function is above this. */
			}



			// ====================================================================================================
			// NATIVES
			// ====================================================================================================
			/* CDirector::ResetMobTimer()
				Resets the Director's natural horde timer. Normally this
				is called when a horde is spawned naturally or by boomer.
				Small function, nearly hits another segment in the file.

				- Find it through only xref, which is setting up ScriptDesc structures: string "Trigger a mob as soon as possible when"
				- If you go past the first call, you should hit unique bytes in sig making
			*/
			"CDirector::ResetMobTimer"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector13ResetMobTimerEv"
				"windows"	"\x55\x8B\xEC\x51\x56\x57\x8D\xB9\x2A\x2A\x2A\x2A\x8B\xCF\xE8\x2A\x2A\x2A\x2A\xD9"
				/* 55 8B EC 51 56 57 8D B9 ? ? ? ? 8B CF E8 ? ? ? ? D9 */
			}

			/*
			 * CDirector::RestartScenarioFromVote(const char*)
			 * Search for unique string "singlechapter"
			 * -> has two xref from same function, CTerrorGameRules::IsSingleChapterMode()
			 * -> has two xref, one is CRestartGameIssue::ExecuteCommand() (exclude the other, CServerGameDLL::ServerHibernationUpdate(), which has string "FCVAR_NEVER_AS_STRING")
			 * -> Last call in CRestartGameIssue::ExecuteCommand
			 */
			"CDirector::RestartScenarioFromVote"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector23RestartScenarioFromVoteEPKc"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x0D\x2A\x2A\x2A\x2A\x57\x85\x2A\x74\x2A\x6A"
				/* ? ? ? ? ? ? 8B 0D ? ? ? ? 57 85 ? 74 ? 6A */
			}

			/*
			 * CTerrorGameRules::GetTeamScore(int,bool)
			 * Find "Staying on original map %s\n"
			 * -> CDirector::Restart(void)
			 * -> showed up near "info_window"
			 * -> called twice along with another function called twice (CterrorGameRules::UpdateChapterScores)
			 */
			"CTerrorGameRules::GetTeamScore"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules12GetTeamScoreEib"
				"windows"	"\x55\x8B\xEC\x8B\x2A\x2A\x85\xC0\x2A\x2A\x33\xC0\x5D\xC2"
				/* 55 8B EC 8B ? ? 85 C0 ? ? 33 C0 5D C2 */
			}

			/* CDirector::IsFirstMapInScenario()
				Uses campaign mission file to determine if the current map
				is a First map.
				Called from CDirector::OnEndScenario, look near string "vs_shutting_down", up to case 7
			*/
			"CDirector::IsFirstMapInScenario"
			{
				"library"	"server"
				"linux"		"@_ZNK9CDirector20IsFirstMapInScenarioEv"
				"windows"	"\xA1\x2A\x2A\x2A\x2A\x8B\x40\x3C\x56\x8B\xF0"
				/* A1 ? ? ? ? 8B 40 3C 56 8B F0 */
			}

			/* CTerrorGameRules::IsMissionFinalMap()
				Uses campaign mission file to determine if the current map
				is a Final(e) map.
				Called from CDirectorVersusMode::EndVersusModeRound(), look near string "versus_match_finished"
			*/
			"CTerrorGameRules::IsMissionFinalMap"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules17IsMissionFinalMapEv"
				"windows"	"\x8B\x0D\x2A\x2A\x2A\x2A\x8B\x01\x8B\x50\x28\x56\xFF\xD2\x8B\x10\x8B\xC8\x8B\x42\x04\x6A\x00\xFF\xD0\x8B\xF0\x85\xF6\x75\x04\xB0"
				/* 8B 0D ? ? ? ? 8B 01 8B 50 28 56 FF D2 8B 10 8B C8 8B 42 04 6A 00 FF D0 8B F0 85 F6 75 04 B0 */
			}

			/* CGameRulesProxy::NotifyNetworkStateChanged()
				This function is called before changing a variety of
				pieces of networked data (data which is reflected in network
				game states).

				- Find "Going to intermission...\n" in CGameRules::GoToIntermission
				- Last call in the func
			*/
			"CGameRulesProxy::NotifyNetworkStateChanged"
			{
				"library"	"server"
				"linux"		"@_ZN15CGameRulesProxy25NotifyNetworkStateChangedEv"
				"windows"	"\xA1\x2A\x2A\x2A\x2A\x85\xC0\x74\x2A\x80\x78"
				/* A1 ? ? ? ? 85 C0 74 ? 80 78 */
			}

			// find string " Highest survivor flow distance = %f Tank at = %f witch at %f\n" in CDirectorVersusMode::UpdateVersusBossSpawning
			// look for __RTDynamicCast which is called on the result of this function.
			"CNavMesh::GetNavArea"
			{
				"library"	"server"
				"linux"		"@_ZNK8CNavMesh10GetNavAreaERK6Vectorf"
				"windows"	"\x55\x8B\xEC\x83\xEC\x2A\x83\x79\x2A\x00\x75\x08\x33\xC0\x8B\xE5\x5D\xC2\x08"
				/* 55 8B EC 83 EC ? 83 79 ? 00 75 08 33 C0 8B E5 5D C2 08 */
			}

			/*
			 * CNavArea::IsConnected(CNavArea const*, NavDirType)const
			 */
			"CNavArea::IsConnected"
			{
				"library"	"server"
				"linux"		"@_ZNK8CNavArea11IsConnectedEPKS_10NavDirType"
				"windows"	"\x55\x8B\x2A\x51\x53\x56\x8B\x2A\x2A\x8B\x2A\x89\x2A\x2A\x3B\x2A\x75\x2A\x5E"
				/* 55 8B ? 51 53 56 8B ? ? 8B ? 89 ? ? 3B ? 75 */
				/* Search: "Created new fencetop area %d(%x) between %d(%x) and %d(%x)\n" - target call is within the if statement below */
			}

			/*
			 * CTerrorPlayer::GetFlowDistance(TerrorNavArea::FlowType)
			 */
			"CTerrorPlayer::GetFlowDistance"
			{
				"library"	"server"
				"linux"		"@_ZNK13CTerrorPlayer15GetFlowDistanceEN13TerrorNavArea8FlowTypeE"
				"windows"	"\x55\x8B\x2A\x8B\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x85\x2A\x74"
				/* 55 8B ? 8B ? 8B ? ? ? ? ? ? ? 85 ? 74 */
				/* Search: "Director state change SUSTAIN_PEAK" few calls below */
				/* Found by "SilverShot" */
			}

			/**
			 * CTerrorPlayer::SetShovePenalty(CTerrorPlayer *this, int)
			 *
			 * 1. Search for "Claw.Swing" and enter the longer function.
			 * 2. XRef this function to the VTable.
			 * 3. Above 2 entries is "CTerrorWeapon::TrySwing" that calls target function.
			 * 4. Compare with Linux.
			 **/
			"CTerrorPlayer::SetShovePenalty"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer15SetShovePenaltyEi"
				"windows"	"\x55\x8B\xEC\x56\x57\x8B\x2A\x2A\x8B\x2A\x39\x2A\xF0\x2C\x00\x00"
				/* 55 8B EC 56 57 8B ? ? 8B ? 39 ? F0 2C 00 00 */
			}

			/**
			 * Thanks to "Psyk0tik" from: https://github.com/Psykotikism/L4D1-2_Signatures
			 * CTerrorPlayer::SetNextShoveTime(float)
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. In IDA Pro, go to the ".rdata" section of the Windows binary.
			 * 3. Search for "CTerrorPlayer::`vftable'" to jump to the "CTerrorPlayer" vtable.
			 * 4. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 5. Look for the target function in the Windows binary.
			 **/
			"CTerrorPlayer::SetNextShoveTime"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer16SetNextShoveTimeEf"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x56\x8B\x2A\x0F\x2F\x2A\x2A\x2A\x2A\x2A\x76\x2A\xF3\x0F\x2A\x2A\x2A\x2A\x2A\x2A\x0F\x2A\x2A\x9F\xF6\x2A\x2A\x7B\x2A\x80\x2A\x2A\x2A\x74\x2A\x80\x2A\x2A\x2A\xF3\x0F\x2A\x2A\x2A\x2A\x2A\x2A\x5E\x5D"
				/* ? ? ? ? ? ? ? ? 56 8B ? 0F 2F ? ? ? ? ? 76 ? F3 0F ? ? ? ? ? ? 0F ? ? 9F F6 ? ? 7B ? 80 ? ? ? 74 ? 80 ? ? ? F3 0F ? ? ? ? ? ? 5E 5D */
			}

			/* CDirector::AreWanderersAllowed(void)
			* Used to get offset for CDirectorScavengeMode
			*	*(director + offset) == ptr to CDirectorScavengeMode
			* has unique string "AlwaysAllowWanderers"
 			*/
			"CDirector::AreWanderersAllowed"
			{
				"library"	"server"
				"linux"		"@_ZNK9CDirector19AreWanderersAllowedEv"
				"windows"	"\x55\x8B\xEC\x83\xEC\x2A\x56\x8B\xF1\x8B\x8E\x2A\x2A\x2A\x2A\x8D\x45\xFF"
				/* 55 8B EC 83 EC ? 56 8B F1 8B 8E ? ? ? ? 8D 45 FF */
			}

			/*
			 * CDirector::IsFinaleEscapeInProgress(void)
			 * unique string "#L4D_idle_spectator" in CTerrorPlayer::PreThink()
			 * CDirector::IsFinaleEscapeInProgress is a couple calls before the string, and a couple calls after CountdownTimer::Now
			 */
			"CDirector::IsFinaleEscapeInProgress"
			{
				"library" 	"server"
				"linux" 	"@_ZNK9CDirector24IsFinaleEscapeInProgressEv"
				"windows" 	"\x8B\x81\x2A\x2A\x2A\x2A\x83\x38\x2A\x75\x03\x32\xC0\xC3\x33\xC0\x83\xB9\x2A\x2A\x2A\x2A\x02\x0F\x94\xC0\xC3"
				/* 8B 81 ? ? ? ? 83 38 ? 75 03 32 C0 C3 33 C0 83 B9 ? ? ? ? 02 0F 94 C0 C3 */
			}

			/*
			 * CTerrorPlayer::TakeOverBot
			 * unique string "[TAKEOVER]: %s (%d) possessed %s"
			 */
			"CTerrorPlayer::TakeOverBot"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer11TakeOverBotEb"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\xC5\x89\x45\xFC\x53\x56\x8D\x85"
				/* ? ? ? ? ? ? ? ? ? A1 ? ? ? ? 33 C5 89 45 FC 53 56 8D 85 */
			}

			/*
			 * SurvivorBot::SetHumanSpectator(CTerrorPlayer*)
			 * Very similar to BossZombiePlayerBot::SetHumanSpectator()
			 * SurvivorBot version has 5 xref (one of them is CTerrorPlayer::TakeOverBot), BossZombie has just 1 (CTerrorPlayer::TakeOverBot)
			 */
			"SurvivorBot::SetHumanSpectator"
			{
				"library"	"server"
				"linux"		"@_ZN11SurvivorBot17SetHumanSpectatorEP13CTerrorPlayer"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x83\xBE\x2A\x2A\x2A\x2A\x00\x7E\x07\x32\xC0\x5E\x5D\xC2\x04\x00\x8B\x0D"
				/* ? ? ? ? ? ? 83 BE ? ? ? ? 00 7E 07 32 C0 5E 5D C2 04 00 8B 0D */
			}

			/*
			 * CTerrorPlayer::SetBecomeGhostAt(CTerrorPlayer *this, float s2)
			 * unique string "ghost_spawn_time"
			 */
			"CTerrorPlayer::SetBecomeGhostAt"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer16SetBecomeGhostAtEf"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x56\x6A\x2A\x68\x2A\x2A\x2A\x2A\x8B\x2A\x68\x2A\x2A\x2A\x2A\xF3"
				/* ? ? ? ? ? ? ? ? 56 6A ? 68 ? ? ? ? 8B ? 68 ? ? ? ? F3 */
				/* Search: "ghost_spawn_time" target is called is above */
			}

			/*
			 * CTerrorPlayer::CanBecomeGhost(bool areSpawnsDisabled)
			 * unique string "ghost_spawn_time"
			 */
			"CTerrorPlayer::CanBecomeGhost"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer14CanBecomeGhostEb"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x83\xE4\xF0\x83\xC4\x04\x55\x8B\x6B\x04\x89\x6C\x24\x04\x8B\xEC\x83\xEC\x78\x56\x57\x8B\xF1"
				/* ? ? ? ? ? ? 83 E4 F0 83 C4 ? 55 8B 6B 04 89 6C 24 ? 8B EC 83 EC 78 56 57 8B F1 */
			}

			/*
			 * SurvivorBot::SetHumanSpectator(CTerrorPlayer*)
			 * Very similar to BossZombiePlayerBot::SetHumanSpectator()
			 * SurvivorBot version has 5 xref (one of them is CTerrorPlayer::TakeOverBot), BossZombie has just 1 (CTerrorPlayer::TakeOverBot)
			 */
			"CTerrorPlayer::GoAwayFromKeyboard"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer18GoAwayFromKeyboardEv"
				"windows"		"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x56\x57\x8B\xF1\x8B\x06\x8B\x90\xC8\x08\x00\x00"
				/* ? ? ? ? ? ? 53 56 57 8B F1 8B 06 8B 90 C8 08 00 00 */
				/* Search "takeover_survivor_bar" */
			}



			// ====================================================================================================
			// l4d2addresses.txt
			// ====================================================================================================
			/*
			 * CTerrorPlayer::OnVomitedUpon(CTerrorPlayer*, bool)
			 */
			"CTerrorPlayer::OnVomitedUpon"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer13OnVomitedUponEPS_b"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x56\x57\x8B\xF1\xE8\x2A\x2A\x2A\x2A\x84\xC0\x74\x2A\x8B\x06\x8B\x90"
				/* ? ? ? ? ? ? 53 56 57 8B F1 E8 ? ? ? ? 84 C0 74 ? 8B 06 8B 90 */
			}

			/*
			 * CTerrorPlayer::OnHitByVomitJar(CBaseCombatCharacter *)
			 */
			"CTerrorPlayer::OnHitByVomitJar"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer15OnHitByVomitJarEP20CBaseCombatCharacter"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x56\x8B\xF1\xE8\x2A\x2A\x2A\x2A\x84\xC0\x74\x2A\x8B\x06\x8B\x90\x2A\x2A\x2A\x2A\x8B\xCE\xFF\xD2\x84\xC0\x0F"
				/* ? ? ? ? ? ? 56 8B F1 E8 ? ? ? ? 84 C0 74 ? 8B 06 8B 90 ? ? ? ? 8B CE FF D2 84 C0 0F */
			}

			/*
			 * Infected::OnHitByVomitJar(CBaseCombatCharacter *)
			 */
			"Infected::OnHitByVomitJar"
			{
				"library"	"server"
				"linux"		"@_ZN8Infected15OnHitByVomitJarEP20CBaseCombatCharacter"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x56\x8B\xF1\x8B\x06\x8B\x90\x2A\x2A\x2A\x2A\xFF\xD2\x84\xC0\x0F\x2A\x2A\x2A\x2A\x2A\x8B\x06\x8B\x90\x2A\x2A\x2A\x2A\x8B\xCE\xFF\xD2\x84\xC0\x75\x2A\x56\xE8\x2A\x2A\x2A\x2A\x8B\xC8\xE8"
				/* ? ? ? ? ? ? 56 8B F1 8B 06 8B 90 ? ? ? ? FF D2 84 C0 0F ? ? ? ? ? 8B 06 8B 90 ? ? ? ? 8B CE FF D2 84 C0 75 ? 56 E8 ? ? ? ? 8B C8 E8 */
			}

			/*
			*	CTerrorPlayer::OnKnockedDown(CBasePlayer *a1, int a2)
			*	Search: "HunterZombie.Pounce.shred". This function contains a sub calling with the param (1).
			*/
			"CTerrorPlayer::OnKnockedDown"
			{
				"library"		"server"
				"linux"			"@_ZN13CTerrorPlayer13OnKnockedDownENS_19KnockdownReasonTypeE"
				"windows"		"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x57\x8D\x2A\x2A\x2A\x2A\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x04\x2A\x2A\x2A\x2A\x9F\x2A\x2A\x2A\x7B\x2A\x8B\x2A\x2A\x8B\x2A\x8D\x2A\x2A\x57\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x74\x2A\x2A\x2A\x2A\x2A\x74"
				/* ? ? ? ? ? ? ? 57 8D ? ? ? ? ? 8B ? E8 ? ? ? ? ? ? ? ? ? ? ? ? 04 ? ? ? ? 9F ? ? ? 7B ? 8B ? ? 8B ? 8D ? ? 57 ? ? ? ? ? ? ? ? ? ? ? 8B ? ? ? ? ? ? ? ? 74 ? ? ? ? ? 74 */
			}

			/*
			*	ThrowImpactedSurvivor(CTerrorPlayer *, CTerrorPlayer *, float, bool)
			*	Search: "charger_impact"
			*/
			"ThrowImpactedSurvivor"
			{
				"library"		"server"
				"linux"			"@_Z21ThrowImpactedSurvivorP13CTerrorPlayerS0_fb"
				"windows"		"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x56\x57\x8B\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\xC1\x2A\x2A\x2A\x2A\x74\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x8B"
				/* ? ? ? ? ? ? 53 56 57 8B ? ? 8B ? ? ? ? ? C1 ? ? ? ? 74 ? ? ? ? ? ? ? ? 8B ? ? ? ? ? 8B */
			}

			/*
			 * CTerrorPlayer::Fling(Vector const&,PlayerAnimEvent_t,CBaseCombatCharacter *,float)
			 *
			 *	Vector: how target is supposed to fly, Animevent is "76" for chargerbounce, CBasePlayer is attacker, float is Incap Animation time
			 *
			 *	Find via CCharge::HandleCustomCollision (strings) -> ThrowImpactedSurvivor (strings, structure) -> Fling (feel it out)
			 *
			 */
			"CTerrorPlayer::Fling"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer5FlingERK6Vector17PlayerAnimEvent_tP20CBaseCombatCharacterf"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x83\xE4\x2A\x83\xC4\x2A\x55\x8B\x6B\x2A\x89\x6C\x2A\x2A\x8B\xEC\x81\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\xC5\x89\x45\x2A\x8B\x43\x2A\x56\x8B\x73\x2A\x57\x6A\x2A\x8B\xF9\x89\x45"
				/* ? ? ? ? ? ? 83 E4 ? 83 C4 ? 55 8B 6B ? 89 6C ? ? 8B EC 81 ? ? ? ? ? A1 ? ? ? ? 33 C5 89 45 ? 8B 43 ? 56 8B 73 ? 57 6A ? 8B F9 89 45 */
			}

			/*
			 * CTerrorPlayer::CancelStagger(void) - used by the game to stop Survivor Staggering as something else happens
			 */
			"CTerrorPlayer::CancelStagger"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer13CancelStaggerEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x0C\x2A\x2A\x2A\x0F\x2A\x2A\x2A\x2A\x2A\x2A\x57\x8D"
				/* Sig may break, using offsets to make unique */
				/* ? ? ? ? ? ? ? 0C ? ? ? 0F ? ? ? ? ? ? 57 8D */
				/* Search "SurvivorWasPounced" - few calls above. */ // Found by "SilverShot" updated by "Crasher_3637".
			}

			/*
			 * CTerrorPlayer::IsMotionControlledXY(Activity)const
			 */
			"CTerrorPlayer::IsMotionControlledXY"
			{
				"library"	"server"
				"linux"		"@_ZNK13CTerrorPlayer20IsMotionControlledXYE8Activity"
				"windows"	"\x55\x8B\x2A\x8B\x2A\x2A\x05\x2A\x2A\x2A\x2A\x3D\x2A\x2A\x2A\x2A\x77"
				/* 55 8B ? 8B ? ? 05 ? ? ? ? 3D ? ? ? ? 77 */
				/* Search "Motion controlled animation" - few calls above. */ // Found by "SilverShot"
			}

			/*
			 * CCharge::ImpactStagger(CCharge *this)
			 */
			"CCharge::ImpactStagger"
			{
				"library"	"server"
				"linux"		"@_ZN7CCharge13ImpactStaggerEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x81\x2A\x2A\x2A\x2A\x2A\x03\x2A\x8D\x2A\x2A\x2A\x85\x2A\x0F\x84\x2A\x2A\x2A\x2A\xC1\x2A\x2A\x39\x2A\x2A\x0F\x85\x2A\x2A\x2A\x2A\x56"
				/* ? ? ? ? ? ? ? ? ? 83 ? ? 83 ? ? 0F 84 ? ? ? ? 8B ? ? ? ? ? 8B ? 81 ? ? ? ? ? 03 ? 8D ? ? ? 85 ? 0F 84 ? ? ? ? C1 ? ? 39 ? ? 0F 85 ? ? ? ? 56 */
				/* Search: "ChargerZombie.Stagger" - should be the only string in the function */ // Found by "SilverShot".
			}

			/*
			 * CTerrorPlayer::OnStartCarryingVictim(CTerrorPlayer *this, CTerrorPlayer *)
			 */
			"CTerrorPlayer::OnStartCarryingVictim"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer21OnStartCarryingVictimEPS_"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x2A\x6A\x00\x6A\x00\x68\x2A\x2A\x2A\x2A\xFF\x2A\x8B\x2A\x85\x2A\x74\x2A\x8B\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x50\x8B\x2A\x2A\xFF\x2A\x8B\x2A\x50\x8B\x2A\x2A\x68\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x8B\x2A\x2A\x8B"
				/* ? ? ? ? ? ? 8B ? 8B ? ? ? ? ? 8B ? 8B ? ? 6A 00 6A 00 68 ? ? ? ? FF ? 8B ? 85 ? 74 ? 8B ? ? 8B ? ? ? ? ? 8B ? 50 8B ? ? FF ? 8B ? 50 8B ? ? 68 ? ? ? ? 8B ? FF ? 8B ? ? 8B */
				/* Search: "charger_carry_start" */ // Found by "SilverShot".
			}

			"CTerrorPlayer::OnSlammedSurvivor"
			{
				"library"		"server"
				"linux"			"@_ZN13CTerrorPlayer17OnSlammedSurvivorEPS_bb"
				"windows"		"\x2A\x2A\x2A\x2A\x2A\x2A\xD9\xEE\x56\x57\x6A\x00\x51\xD9\x2A\x24\x68\x2A\x2A\x2A\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\xF3\x0F"
				/* ? ? ? ? ? ? D9 EE 56 57 6A 00 51 D9 ? 24 68 ? ? ? ? 8B ? E8 ? ? ? ? F3 0F */
				/* Search "ChargerZombie.ImpactHard" */ // Found by "Forgetest"
			}

			/*
			*	CTerrorPlayer::QueuePummelVictim(CTerrorPlayer*)
			*	int __cdecl CTerrorPlayer::QueuePummelVictim(int a1, int a2, float a3)
			*	Search: "ChargerZombie.VocalizePummel". xref calls sub_#### ((void *)v2, 0, -1.0);
			*/
			"CTerrorPlayer::QueuePummelVictim"
			{
				"library"		"server"
				"linux"			"@_ZN13CTerrorPlayer17QueuePummelVictimEPS_f"
				"windows"		"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x56\x57\x8B\x2A\x85\x2A\x74\x2A\x8B\x2A\x8B\x2A\x2A\x8B\x2A\xFF\x2A\x8B\x2A\x83\x2A\xFF\x74"
				/* ? ? ? ? ? ? ? 56 57 8B ? 85 ? 74 ? 8B ? 8B ? ? 8B ? FF ? 8B ? 83 ? FF 74 */
			}

			/*
			*	CTerrorPlayer::OnPummelEnded(bool, CTerrorPlayer*)
			*	Search: "charger_pummel_end"
			*/
			"CTerrorPlayer::OnPummelEnded"
			{
				"library"		"server"
				"linux"			"@_ZN13CTerrorPlayer13OnPummelEndedEbPS_"
				"windows"		"\x55\x8B\xEC\x8B\x2A\x2A\x2A\x2A\x2A\x53\x56\x8B\xF1\x8B\x2A\x2A\x2A\x2A\x2A\x57"
				/* 55 8B EC 8B ? ? ? ? ? 53 56 8B F1 8B ? ? ? ? ? 57 */
			}

			/*
			 * CTerrorPlayer::OnCarryEnded(CTerrorPlayer *this, bool, bool, bool)
			 */
			"CTerrorPlayer::OnCarryEnded"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer12OnCarryEndedEbbb"
				"windows"	"\x55\x8B\x2A\x53\x56\x8B\x2A\x2A\x2A\x2A\x2A\x57\x8B\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x8D"
				/* 55 8B ? 53 56 8B ? ? ? ? ? 57 8B ? 8B ? ? ? ? ? 8D */
				/* Search: "charger_carry_end" */ // Found by "SilverShot".
			}

			/*
			 * CTerrorPlayer::OnRideEnded(CTerrorPlayer *this, CTerrorPlayer *)
			 */
			"CTerrorPlayer::OnRideEnded"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer11OnRideEndedEPS_"
				"windows"	"\x55\x8B\x2A\x83\x2A\x2A\x53\x56\x57\x68\x2A\x2A\x2A\x2A\x8B\x2A\xE8"
				/* 55 8B ? 83 ? ? 53 56 57 68 ? ? ? ? 8B ? E8 */
				/* Search: "SurvivorJockeyEnded.Ride" */ // Found by "SilverShot".
			}

			/*
			 * CTerrorPlayer::ReleaseTongueVictim(CTerrorPlayer *this, bool)
			 */
			"CTerrorPlayer::ReleaseTongueVictim"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer19ReleaseTongueVictimEb"
				"windows"	"\x53\x8B\x2A\x83\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x55\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x83\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x56\x8B\x2A\x2A\x2A\x2A\x2A\x57\x89"
				/* 53 8B ? 83 ? ? 83 ? ? 83 ? ? 55 8B ? ? 89 ? ? ? 8B ? 83 ? ? 8B ? ? ? ? ? 56 8B ? ? ? ? ? 57 89 */
				/* Search: "Tongue letting go because of damage" target function is called not far below */ // Found by "SilverShot".
			}

			/*
			 * CTerrorPlayer::OnPounceEnded(CTerrorPlayer *this)
			 */
			"CTerrorPlayer::OnPounceEnded"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer13OnPounceEndedEv"
				"windows"	"\x55\x8B\x2A\x51\x53\x8B\x2A\x80\x2A\x2A\x2A\x2A\x2A\x2A\x56\x74"
				/* 55 8B ? 51 53 8B ? 80 ? ? ? ? ? ? 56 74 */
				/* Search: "pounce_end */ // Found by "SilverShot".
			}

			/*
			 * CDirector::CreateRescuableSurvivors(void)
			 */
			"CDirector::CreateRescuableSurvivors"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector24CreateRescuableSurvivorsEv"
				"windows"	"\x55\x8B\x2A\x83\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x83\x2A\x2A\x2A\x57\x8B\x2A\x89\x2A\x2A\x0F\x85"
				/* 55 8B ? 83 ? ? A1 ? ? ? ? 83 ? ? ? 57 8B ? 89 ? ? 0F 85 */ // Updated by SilverShot.
				/* String "rescue spot %d(%s) stops calling for he" */
			}

			/*
			 * CTerrorGameRules::GetVersusCompletion(CTerrorPlayer *)
			 */
			"CTerrorGameRules::GetVersusCompletion"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules19GetVersusCompletionEP13CTerrorPlayer"
				"windows"	"\x55\x8B\x2A\x83\x2A\x2A\x53\x56\x8B\x2A\x2A\x8B\x2A\x85\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\xE8"
				/* 55 8B ? 83 ? ? 53 56 8B ? ? 8B ? 85 ? 0F 84 ? ? ? ? 8B ? E8 */ // Found by "SilverShot".
				/* Found via "RecomputeTeamScores" and "RecomputeVersusCompletion" function. Difficult but can be matched comparing Nix/Win HexRays */
			}

			/*
			* CDirectorTacticalServices::GetHighestFlowSurvivor(TerrorNavArea::FlowType)const
			*/
			"CDirectorTacticalServices::GetHighestFlowSurvivor"
			{
				"library"	"server"
				"linux"		"@_ZNK25CDirectorTacticalServices22GetHighestFlowSurvivorEN13TerrorNavArea8FlowTypeE"
				"windows"	"\x55\x8B\x2A\x83\x2A\x2A\xF3\x0F\x2A\x2A\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x89\x2A\x2A\x89"
				/* 55 8B ? 83 ? ? F3 0F ? ? ? ? ? ? 33 ? 89 ? ? 89 ? ? 89 */ // Found by "SilverShot".
				/* Search "Director state change SUSTAIN_PEAK". Call below. */
			}

			/*
			 * Infected::GetFlowDistance(void)const
			 */
			"Infected::GetFlowDistance"
			{
				"library"	"server"
				"linux"		"@_ZNK8Infected15GetFlowDistanceEv"
				"windows"	"\x8B\x01\x8B\x90\x2A\x2A\x2A\x2A\xFF\xD2\x85\xC0\x74\x2A\xD9\x80\x2A\x2A\x2A\x2A\xC3"
				/* 8B 01 8B 90 ? ? ? ? FF D2 85 C0 74 ? D9 80 ? ? ? ? C3 */
			}

			/*
			 * CTerrorPlayer::TakeOverZombieBot(CTerrorPlayer*)
			 *
			 * for finding:
			 * "bot_player_replace"
			 */
			"CTerrorPlayer::TakeOverZombieBot"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer17TakeOverZombieBotEPS_"
				"windows"	"\x55\x8B\xEC\x81\xEC\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\xC5\x89\x45\x2A\x53\x8B\x5D\x2A\x80"
				/* 55 8B EC 81 EC ? ? ? ? A1 ? ? ? ? 33 C5 89 45 ? 53 8B 5D ? 80 */
			}

			/*
			 * CTerrorPlayer::ReplaceWithBot(bool)
			 *
			 * for finding: in CDirector::UpdateTankSpawns, easily findable in graph view
			 * "TANK OFFER: No tickets, choosing random"
			 */
			"CTerrorPlayer::ReplaceWithBot"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer14ReplaceWithBotEb"
				"windows"	"\x55\x8B\xEC\x81\xEC\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\xC5\x89\x45\x2A\x56\x8B\xF1\x8B\x06\x8B\x90\x2A\x2A\x2A\x2A\xFF\xD2\x84\xC0\x74"
				/* 55 8B EC 81 EC ? ? ? ? A1 ? ? ? ? 33 C5 89 45 ? 56 8B F1 8B 06 8B 90 ? ? ? ? FF D2 84 C0 74 */
			}

			/*
			 * CTerrorPlayer::CullZombie(void)
			 * Called in ReplaceTank, followed by a call to CCSPlayer::State_Transition
			 */
			"CTerrorPlayer::CullZombie"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer10CullZombieEv"
				"windows"	"\x55\x8B\xEC\x83\xEC\x2A\x56\x8B\xF1\x8B\x0D\x2A\x2A\x2A\x2A\x57\x56\xE8"
				/* 55 8B EC 83 EC ? 56 8B F1 8B 0D ? ? ? ? 57 56 E8 */
			}

			/*
			* CTerrorPlayer::CleanupPlayerState(CTerrorPlayer *this)
			*/
			"CTerrorPlayer::CleanupPlayerState"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer18CleanupPlayerStateEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x55\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x0F\x2A\x2A\x83\x2A\x2A\x56\x8B\x2A\xC7"
				/* ? ? ? ? ? ? 83 ? ? 83 ? ? 55 8B ? ? 89 ? ? ? 8B ? 0F ? ? 83 ? ? 56 8B ? C7 */
				/* Search "Tongue letting go on death." the function with "Player.Heartbeat" at the bottom */
			}

			/*
			 * CTerrorPlayer::SetClass(CBaseEntity *, int)
			 */
			"CTerrorPlayer::SetClass"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer8SetClassE15ZombieClassType"
				"windows"	"\x55\x8B\x2A\x56\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x83\x2A\x2A\x0F\x85\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x40\xA3"
				/* 55 8B ? 56 8B ? E8 ? ? ? ? 83 ? ? 0F 85 ? ? ? ? A1 ? ? ? ? 40 A3 */ // Updated by SilverShot.
				/* Search "weapon_smoker_claw" */
			}

			/*
			 * CBaseAbility::CreateForPlayer(CBaseAbility *this, CTerrorPlayer *)
			 */
			"CBaseAbility::CreateForPlayer"
			{
				"library"	"server"
				"linux"		"@_ZN12CBaseAbility15CreateForPlayerEP13CTerrorPlayer"
				"windows"	"\x55\x8B\x2A\x83\x2A\x2A\x56\x8B\x2A\x2A\x85\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x83"
				/* 55 8B ? 83 ? ? 56 8B ? ? 85 ? 0F 84 ? ? ? ? 8B ? E8 ? ? ? ? 83 */ // Updated by SilverShot.
				/* Search "ability_tongue" */
			}

			/*
			 * CTerrorPlayer::MaterializeFromGhost(void)
			 */
			"CTerrorPlayer::MaterializeFromGhost"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer20MaterializeFromGhostEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x50\xE8\x2A\x2A\x2A\x2A\x83\x2A\x2A\x50\x8B\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x50\x68\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x68"
				/* ? ? ? ? ? ? ? ? ? ? ? ? ? 50 E8 ? ? ? ? 83 ? ? 50 8B ? 8B ? ? ? ? ? 8B ? ? ? 50 68 ? ? ? ? E8 ? ? ? ? 68 */
				/* Search "%s materialized from spawn mode as a %s" */
			}

			/* CTerrorPlayer::BecomeGhost(bool) */
			"CTerrorPlayer::BecomeGhost"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer11BecomeGhostEb"
				"windows"	"\x55\x8B\xEC\x53\x8B\x5D\x2A\x56\x53\x8B\xF1\xE8\x2A\x2A\x2A\x2A\x84"
				/* 55 8B EC 53 8B 5D ? 56 53 8B F1 E8 ? ? ? ? 84 */
			}

			/* CCSPlayer::State_Transition(CSPlayerState) */
			"CCSPlayer::State_Transition"
			{
				"library"	"server"
				"linux"		"@_ZN9CCSPlayer16State_TransitionE13CSPlayerState"
				"windows"	"\x55\x8B\xEC\x56\x8B\xF1\x8B\x86\x2A\x2A\x2A\x2A\x57\x8B\x7D\x2A\x85\xC0\x74\x2A\x83"
				/* 55 8B EC 56 8B F1 8B 86 ? ? ? ? 57 8B 7D ? 85 C0 74 ? 83 */
			}

			/*
			 * CDirector::SwapTeams(void)
			 */
			"CDirector::SwapTeams"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector9SwapTeamsEv"
				"windows"	"\x55\x8B\x2A\x81\x2A\x2A\x2A\x2A\x2A\x53\x56\x8B\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x57\x89"
				/* 55 8B ? 81 ? ? ? ? ? 53 56 8B ? 8B ? ? ? ? ? 57 89 */
				/* Search: "Switching Survivor Bot '%s' from team %d to SPECTATOR\n" */
			}

			/*
			 * CDirector::AreTeamsFlipped(void)const
			 *
			 * got via CTerrorPlayer::UpdateTeamDesired and its String "CTerrorPlayer::UpdateTeamDesired error "
			 *
			 */
			"CDirector::AreTeamsFlipped"
			{
				"library"	"server"
				"linux"		"@_ZNK9CDirector15AreTeamsFlippedEv"
				"windows"	"\x57\x8B\xF9\xE8\x2A\x2A\x2A\x2A\x84\xC0\x75\x2A\xF7"
				/* 57 8B F9 E8 ? ? ? ? 84 C0 75 ? F7 */
			}

			/*
			 * CDirector::StartRematchVote(void)
			 */
			"CDirector::StartRematchVote"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector16StartRematchVoteEv"
				"windows"	"\x83\x2A\x2A\x56\x8B\xF1\x68\x2A\x2A\x2A\x2A\x6A\x2A\xB9\x2A\x2A\x2A\x2A\xC6"
				/* 83 ? ? 56 8B F1 68 ? ? ? ? 6A ? B9 ? ? ? ? C6 */ // Found by "SilverShot".
				/* Search: "PZEndGame" one of two. */
			}

			/*
			 * CDirector::FullRestart(void)
			 */
			"CDirector::FullRestart"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector11FullRestartEv"
				"windows"	"\x56\x8B\x2A\xC7\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\xE8"
				/* 56 8B ? C7 ? ? ? ? ? ? ? ? ? E8 ? ? ? ? E8 */ // Found by "SilverShot".
				/* Search "Staying on original map" for "CDirector::Restart". XRef - small function.*/
			}

			/*
			 * CDirectorVersusMode::HideScoreboardNonVirtual(void)
			 */
			"CDirectorVersusMode::HideScoreboardNonVirtual"
			{
				"library"	"server"
				"linux"		"@_ZN19CDirectorVersusMode24HideScoreboardNonVirtualEv"
				"windows"	"\x55\x8B\x2A\x83\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x74\x2A\x53\x8D"
				/* 55 8B ? 83 ? ? E8 ? ? ? ? 84 ? 74 ? 53 8D */ // Found by "SilverShot".
				/* String "fullscreen_vs_results" */
			}

			/*
			 * CDirectorScavengeMode::HideScoreboardNonVirtual(void)
			 */
			"CDirectorScavengeMode::HideScoreboardNonVirtual"
			{
				"library"	"server"
				"linux"		"@_ZN21CDirectorScavengeMode24HideScoreboardNonVirtualEv"
				"windows"	"\x55\x8B\x2A\x83\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x74\x2A\x33\x2A\x88"
				/* 55 8B ? 83 ? ? E8 ? ? ? ? 84 ? 74 ? 33 ? 88 */
				/* Search: "fullscreen_scavenge_scoreboard" (smaller function) */
			}

			/*
			 * CDirector::HideScoreboard(void)
			 */
			"CDirector::HideScoreboard"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector14HideScoreboardEv"
				"windows"	"\x56\x8B\x2A\x8B\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B"
				/* 56 8B ? 8B ? ? ? ? ? E8 ? ? ? ? 8B ? ? ? ? ? E8 ? ? ? ? 8B */ // Found by "SilverShot".
				/* Search "message_box". Function with 1 string. Xref is target. */
			}

			/*
			 * CDirector::RegisterForbiddenTarget(CBaseEntity *) - used to create Car Alarms
			 */
			"CDirector::RegisterForbiddenTarget"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector23RegisterForbiddenTargetEP11CBaseEntity"
				"windows"	"\x55\x8B\x2A\x51\x56\x8B\x2A\xE8\x2A\x2A\x2A\x2A\xD9\x2A\x2A\x2A\x2A\x2A\xF3"
				/* 55 8B ? 51 56 8B ? E8 ? ? ? ? D9 ? ? ? ? ? F3 */ // Found by "SilverShot"
				/* Search: "prop %s at %.0f %.0f %0.f missing model" for "CBaseProp::Spawn". XRef called by "CBreakableProp::Spawn" (largest function) which calls target function */
			}

			/*
			 * CDirector::UnregisterForbiddenTarget(CBaseEntity *) - used to remove Car Alarms
			 */
			"CDirector::UnregisterForbiddenTarget"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector25UnregisterForbiddenTargetEP11CBaseEntity"
				"windows"	"\x55\x8B\x2A\x56\x57\x8B\x7D\x08\x8B\xF1\x85\xFF\x74\x2A\x8B\x07\x8B\x50\x08\x8B\xCF\xFF\xD2\x8B\x00\x89\x45\x08"
				/* 55 8B ? 56 57 8B 7D 08 8B F1 85 FF 74 ? 8B 07 8B 50 08 8B CF FF D2 8B 00 89 45 08 */ // Found by "SilverShot" updated by "Crasher_3637"
				/* Search "triggered_car_alarm" for "CCarProp::InputSurvivorStandingOnCar". Called in here. */
			}



			// UNUSED / BROKEN

			/*
			 * CTerrorGameRules::ClearScavengeScores(bool)
			 */
			"CTerrorGameRules::ClearScavengeScores"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules19ClearScavengeScoresEb"
				"windows"	""
				/* */
				/* found in CDirector::OnServerShutDown via String "ServerConfig.vdf" */
			}

			/*
			 * CTerrorGameRules::ClearRoundDurations(void)
			 */
			"CTerrorGameRules::ClearRoundDurations"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules19ClearRoundDurationsEv"
				"windows"	""
				/* */
			}

			/*
			 * CDirectorVersusMode::ClearTeamScoresNonVirtual(bool)
			 */
			"CDirectorVersusMode::ClearTeamScoresNonVirtual"
			{
				"library"	"server"
				"linux"		"@_ZN19CDirectorVersusMode25ClearTeamScoresNonVirtualEb"
				"windows"	""
				/* */
			}

			/*
			 * CTerrorPlayer::Vocalize(char const *, float, float)
			 * does not bypass new Valve Vocalize Lock
			 */
			"Vocalize"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer8VocalizeEPKcff"
				"windows"	"\x55\x8B\x2A\x51\x0F\x57\x2A\xD9"
				/* 55 8B ? 51 0F 57 ? D9 */ // Updated by SilverShot.
				/* Search: "BoomerZombie.Groan", call below. */
			}

			/*
			 * CTerrorGameRules::GetVersusCompletionPerCharacter(SurvivorCharacterType, int)const
			 *
			 * survivorCharacterType is likely int, 0-3 or 1-4
			 * function can be found via the CDirectorVersusMode::UpdateMarkersReached(void) function, unique string "versus_marker_reached"
			 */
			"CTerrorGameRules::GetVersusCompletionPerCharacter"
			{
				"library"	"server"
				"linux"		"@_ZNK16CTerrorGameRules31GetVersusCompletionPerCharacterE21SurvivorCharacterTypei"
				"windows"	"\x55\x8B\x2A\x8B\x2A\x2A\x56\x50\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x8D\x2A\x2A\x2A\x8B"
				/* 55 8B ? 8B ? ? 56 50 8B ? E8 ? ? ? ? 8B ? ? 8D ? ? ? 8B */ // Updated by SilverShot.
			}

			/*
			 * CTerrorGameRules::RecordInfectedDamageForVersus(int)
			 *
			 * Found using AreTeamsFlipped and NotifyNetWorkStateChanged - but im not sure its the right one
			 */
			"CTerrorGameRules::RecordInfectedDamageForVersus"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules29RecordInfectedDamageForVersusEi"
				"windows"	"\x55\x8B\x2A\xF7\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x53\x56"
				/* 55 8B ? F7 ? ? ? ? ? ? ? ? ? 53 56 */ // Found by "SilverShot".
				/* Search "victim_x" for "CTerrorGameRules::PopulateDeathEvent". Xref to vtable.
				 * Function below is "CTerrorGameRules::TrackPlayerZombieDamage". This calls target.
				 * Probably correct, Win looks different to Nix.
				*/
			}

			/*
			 * CNavArea::IsBlocked(int, bool)const
			 */
			"CNavArea::IsBlocked"
			{
				"library"	"server"
				"linux"		"@_ZNK8CNavArea9IsBlockedEib"
				"windows"	"\x55\x8B\x2A\x80\x2A\x2A\x2A\x74\x2A\x8B\x2A\x2A\x85\x2A\x79"
				/* 55 8B ? 80 ? ? ? 74 ? 8B ? ? 85 ? 79 */ // Found by "SilverShot".
				/* Search: "BLOCKED_SURVIVOR". Above/below is target. */
			}

			/*
			 * NavAreaBuildPath<ShortestPathCost>(CNavArea *a1_CNavArea, CNavArea *a2_CNavArea, int a3__vector, int a4__vector, int a5, int a6, int a7_flMaxPathLength, int a8_teamID, int a9_ignoreNavBlockers)
			 */
			"NavAreaBuildPath_ShortestPathCost"
			{
				"library"	"server"
				"linux"		"@_Z16NavAreaBuildPathI16ShortestPathCostEbP8CNavAreaS2_PK6VectorS5_RT_PS2_fib"
				"windows"	"\x53\x8B\x2A\x83\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x55\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x83\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x56\x89"
				/* 53 8B ? 83 ? ? 83 ? ? 83 ? ? 55 8B ? ? 89 ? ? ? 8B ? 83 ? ? A1 ? ? ? ? 33 ? 56 89 */ // Found by "SilverShot".
				/* Search: "NavAreaBuildPath". Should be first sub. */
			}



			// ====================================================================================================
			// POINTERS
			// ====================================================================================================
			/* Find the Director/ZombieManager singleton classes */
			"TheDirector"
			{
				"library"	"server"
				"linux"		"@TheDirector"
			}

			/* Used solely to get the offset for TheDirector
			 * CDirectorMusicBanks::OnRoundStart
			 * Has unique string "Event.Reveal"
			*/
			"CDirectorMusicBanks::OnRoundStart"
			{
				"library"	"server"
				"windows"	"\x55\x8B\xEC\x83\xEC\x2A\x56\x57\x8B\xF9\x8B\x0D\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x84\xC0\x0F"
				/* 55 8B EC 83 EC ? 56 57 8B F9 8B 0D ? ? ? ? E8 ? ? ? ? 84 C0 0F */
			}

			"TheZombieManager"
			{
				"library"	"server"
				"linux"		"@TheZombieManager"
			}

			/*
			 * InfoChangelevel::StartChangeLevel(Checkpoint const*)
			 *
			 * Used for finding ZombieManager on Windows
			 * - String "Would change level, but not going to!\n" is unique to this function
			 */
			"StartChangeLevel"
			{
				"library"	"server"
				"linux"		"@_ZN15InfoChangelevel16StartChangeLevelEPK10Checkpoint"
				"windows"	"\x55\x8B\xEC\xA1\x2A\x2A\x2A\x2A\x83\x78\x30\x00\x56\x8B\xF1\x74"
				/* 55 8B EC A1 ? ? ? ? 83 78 30 00 56 8B F1 74 */
			}

			/*
			 * CVEngineServer::CreateFakeClient(CVEngineServer *this, const char *)
			 */
			"CVEngineServer::CreateFakeClient"
			{
				"library"	"engine"
				"linux"		"@_ZN14CVEngineServer16CreateFakeClientEPKc"
				"windows"	"\x55\x8B\x2A\x8B\x2A\x2A\x50\xB9\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x85\x2A\x75\x2A\x5D\xC2"
				/* 55 8B ? 8B ? ? 50 B9 ? ? ? ? E8 ? ? ? ? 85 ? 75 ? 5D C2 */
				/* Search: "cl_updaterate" - function with many strings together. Called by target. */
			}

			"g_pGameRules"
			{
				"library"	"server"
				"linux"		"@g_pGameRules"
			}

			/* This signature sometimes has multiple matches, but this
			 * does not matter as g_pGameRules is involved in all of them.
			 * The same g_pGameRules offset applies to each match.
			 *
			 * Sometimes this block of bytes is at the beginning of the static
			 * CreateGameRulesObject function and sometimes it is in the middle
			 * of an entirely different function. This depends on the game.
			 */
			"CreateGameRulesObject"
			{
				"library"	"server"
				"windows"	"\x55\x8B\xEC\x8B\x0D\x2A\x2A\x2A\x2A\x85\xC9\x74\x2A\x8B\x01\x8B\x50\x30"
				/* 55 8B EC 8B 0D ? ? ? ? 85 C9 74 ? 8B 01 8B 50 30 */
			}

			/* Find the WeaponInfo Database dictionary */
			"WeaponInfoDatabase"
			{
				"library"	"server"
				"linux"		"@_ZL20m_WeaponInfoDatabase"
			}

			/*
			 * ReadWeaponDataFromFileForSlot(int, char *s, int, int)
			 *
			 * We can find the WeaponInfoDatabase address in this sub on Windows
			 *
			 * Look for "scripts/%s", should be the ref that's furthest into a func.
			 * OR
			 * Look for unique string "scripts/weapon_manifest.txt", then look in same func for almost unique string "Expecting 'file', got %s\n", should be two calls before that string
			*/
			"ReadWeaponDataFromFileForSlot"
			{
				"library"	"server"
				"windows"	"\x55\x8B\xEC\x81\xEC\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\xC5\x89\x45\xFC\x8B\x45\x14\x53\x8B\x5D\x10"
				/* 55 8B EC 81 EC ? ? ? ? A1 ? ? ? ? 33 C5 89 45 FC 8B 45 14 53 8B 5D 10 */
			}

			/* Find the Melee Weapon Info dictionary */
			"CMeleeWeaponInfoStore"
			{
				"library"	"server"
				"linux"		"@g_MeleeWeaponInfoStore"
			}

			/* We can find the MeleeWeaponInfoStore address in this sub on Windows
			 *
			 * "NULL Ent '%s' in GiveNamedItem!\n" is unique in this function
			 * There are at least 3 calls using the g_MeleeWeaponInfoStore here--use some brain for offset.
			 */
			"GiveNamedItem"
			{
				"library"	"server"
				"windows"	"\x55\x8B\xEC\x81\xEC\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\xC5\x89\x45\xFC\x8B\x45\x14\x53\x8B\x5D\x08"
					/* 55 8B EC 81 EC ? ? ? ? A1 ? ? ? ? 33 C5 89 45 FC 8B 45 14 53 8B 5D 08 */
			}

			"nav_update_lighting"
			{
				"library"	"server"
				"linux"		"@_ZL19nav_update_lightingRK8CCommand"
				"windows"	"\x55\x8B\x2A\x8B\x2A\x2A\x57\x33\x2A\x83\x2A\x2A\x75"
				/* 55 8B ? 8B ? ? 57 33 ? 83 ? ? 75 */
				/* Search: "Computed lighting for %d/%d areas\n" */
			}

			"TheNavAreas"
			{
				"library"	"server"
				"linux"		"@TheNavAreas"
			}

			"TheNavMesh"
			{
				"library"	"server"
				"linux"		"@TheNavMesh"
			}

			/* Used solely to get the offset for TheNavMesh
			 * Look for string "Navigation map '%s' saved.\n" in a short function
			*/
			"CommandNavSave"
			{
				"library"	"server"
				"windows"	"\xE8\x2A\x2A\x2A\x2A\x84\xC0\x74\x2A\x8B\x0D\x2A\x2A\x2A\x2A\x8B\x01\x8B\x50\x2A\xFF\xD2\x8B\x0D\x2A\x2A\x2A\x2A\x84\xC0"
				/* E8 ? ? ? ? 84 C0 74 ? 8B 0D ? ? ? ? 8B 01 8B 50 ? FF D2 8B 0D ? ? ? ? 84 C0 */
			}



			// ====================================================================================================
			// ADDONS DISABLER
			// ====================================================================================================
			// Details on finding offsets can be found here: https://github.com/ProdigySim/left4dhooks/pull/1
			// Big thanks to "ProdigySim" for updating for The Last Stand update.

			/*
			* CBaseServer::FillServerInfo(SVC_ServerInfo *)
			*/
			"CBaseServer::FillServerInfo"
			{
				"library"	"engine"
				"linux"		"@_ZN11CBaseServer14FillServerInfoER14SVC_ServerInfo"
				"windows"	"\x55\x8B\xEC\x53\x56\x57\x68\x04\x01\x00\x00"
				/* 55 8B EC 53 56 57 68 04 01 00 00 */
				/* Search: "Game/mode" - second entry is target */
			}

			/*
			* CBaseServer::GetClient(int)
			*/
			"CBaseServer::GetClient"
			{
				"library"	"engine"
				"linux"		"@_ZN11CBaseServer9GetClientEi"
				"windows"	"\x55\x8B\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x8B\x2A\x2A\x85\x2A\x74"
				/* 55 8B ? 8B ? ? ? ? ? 8B ? ? 8B ? ? 85 ? 74 */
				/* Vtable */
			}

			/*
			* Instruction where CBaseServer::FillServerInfo saves the result of the "Game/vanilla" check to member variable.
			* Should be near instructions filling member variables with "L" or "W"
			* Linux:
                        * mov     [esi+55h], al
			* mov     dword ptr [esp], 'L' ; c
			* Windows:
			* MOV        byte ptr [EDI + 0x5d],BL
        		* MOV        dword ptr [EDI + 0x8c],DAT_10678ec8
			* MOV        dword ptr [EDI + 0x90],DAT_10678dc0
        		* MOV        byte ptr [EDI + 0x5f],'W'
			*/
			"VanillaModeOffset"
			{
				"library"	"engine"
				"linux"		"\x88\x2A\x55\xC7\x04\x24\x4C"
				/* 88 ? 55 C7 04 24 4C */
				"windows"	"\x88\x5F\x5D\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xC6\x47\x5F\x57"
				/* 88 5F 5D ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? C6 47 5F 57 */
			}



			// ====================================================================================================
			// LOBBY RESERVATION
			// ====================================================================================================
			/*
			 * CBaseServer::SetReservationCookie(uint64_t, char*, va_list)
			 * - clear the reservation by setting a cookie of 0
			 */
			"CBaseServer::SetReservationCookie"
			{
				"library"	"engine"
				"linux"		"@_ZN11CBaseServer20SetReservationCookieEyPKcz"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x53\x8B\x2A\x2A\x56\x8B\x2A\x2A\x57\x8B\x2A\x2A\x3B"
				/* ? ? ? ? ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 53 8B ? ? 56 8B ? ? 57 8B ? ? 3B */
				// Wildcarded so compatible with l4dtoolz.
				// "windows"	"\x55\x8B\x2A\x81\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x53\x8B\x2A\x2A\x56\x8B\x2A\x2A\x57\x8B\x2A\x2A\x3B"
				/* 55 8B ? 81 ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 53 8B ? ? 56 8B ? ? 57 8B ? ? 3B */
			}



			// ====================================================================================================
			// PLAYER SLOTS PATCHING - UNUSED
			// ====================================================================================================
			/*
			* CTerrorGameRules::GetMaxHumanPlayers(void)
			* We just override the return value to our own
			*
			* This method is called for max players when viewing server info
			* Overriding this on Linux changes the server browser maxplayers
			*
			* On Windows overriding it doesn't fix the server browser,
			* but it does break scavenge mode (like the map doesn't support scavenge)
			*
			* Find via string "playercontrolledzombies", unique in Linux, inlined a few times in Windows
			* look for an inline that is very short and returns either 8 or 4 as a result
			* Commented out since the note above suggests it breaks scavenge?
			* Since it is inlined, its signature will look a LOT like CTerrorGameRules::HasPlayerControlledZombies()
			* this sig is probably also excessively wild carded (lots of very short local jumps that are probably safe)
			*/
			"GetMaxHumanPlayers"
			{
				"library" "server"
				"linux" "@_ZNK16CTerrorGameRules18GetMaxHumanPlayersEv"
				// "windows" "\xF7\x05\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x74\x2A\xB8\x2A\x2A\x2A\x2A\xEB\x2A\xA1\x2A\x2A\x2A\x2A\x8B\x40\x2A\x85\xC0\x75\x2A\xB8\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x2A\x2A\x8B\x11\x50\x8B\x2A\x2A\xFF\xD0\x85\xC0\x74\x2A\x6A\x00\x68\x2A\x2A\x2A\x2A\x8B\xC8\xE8\x2A\x2A\x2A\x2A\x85\xC0\xB8"
				/* F7 05 ? ? ? ? ? ? ? ? 74 ? B8 ? ? ? ? EB ? A1 ? ? ? ? 8B 40 ? 85 C0 75 ? B8 ? ? ? ? 8B ? ? ? ? ? 8B 11 50 8B ? ? FF D0 85 C0 74 ? 6A 00 68 ? ? ? ? 8B C8 E8 ? ? ? ? 85 C0 B8 */
			}

			/*
			* Total Number of Players Supported (Steam Group/Lobby)
			* Currently disabled - SourceMod unable to look up other libraries.
			*
				"GetTotalNumPlayersSupported"
				{
					"library"	"matchmaking_ds"
					"linux"		"@_ZN11CMatchTitle27GetTotalNumPlayersSupportedEv"
				}
			*/

			/* CServerGameClients::GetPlayerLimits(int& , int&, int&)
			* Sig is still broken, cannot find in Windows
			*/
			"GetPlayerLimits"
			{
				"library"	"server"
				"linux"		"@_ZNK18CServerGameClients15GetPlayerLimitsERiS0_S0_"
				// "windows"	"\x8B\x44\x24\x04\x8B\x4C\x24\x08\xC7\x00\x2A\x2A\x2A\x2A\xC7\x01\x2A\x2A\x2A\x2A\x8B\x10"
					/* 8B 44 24 04 8B 4C 24 08 C7 00 ? ? ? ? C7 01 ? ? ? ? 8B 10 */
			}

			/*
			* int CBaseServer::GetMasterServerPlayerCounts(int &, int &, int &)
			*
			* Used to override server browser maxplayers reporting (Windows)
			* Search for string: "increased_maxplayers", call is just before the string
			*/
			"GetMasterServerPlayerCounts"
			{
				"library"	"engine"
				"linux"		"@_ZN11CBaseServer27GetMasterServerPlayerCountsERiS0_S0_"
				"windows"	"\x55\x8B\xEC\x56\x8B\xF1\xE8\x2A\x2A\x2A\x2A\x8B\x4D\x2A\x89\x01\x8B\x0D\x2A\x2A\x2A\x2A\x85\xC9\x74"
				/* 55 8B EC 56 8B F1 E8 ? ? ? ? 8B 4D ? 89 01 8B 0D ? ? ? ? 85 C9 74 */
			}

			/* Not an actual function,
			 * this is inside CBaseServer::ConnectClient (a jz instruction)
			 * use it to remove skippable code when sv_allow_lobby_connect 0
			*/
			"ConnectClientLobbyCheck"
			{
				/* look for jz between "#Valve_Reject_Server_Full" and "#Valve_Reject_Bad_Password" in Windows
				 * On Linux, this points directy at the cmp for "#Valve_Reject_Server_Full" instead of the jz for the lobby
				 * For 2.1.2.5 this offset was ebx+17Ch on Linux and esi+180h on Windows */
				"library"	"engine"
				"linux"		"\x3B\xB3\x2A\x2A\x2A\x2A\x0F\x8E\x2A\x2A\x2A\x2A\x8B\x03\xC7\x44\x24\x08\x2A\x2A\x2A\x2A\x89"
				/* 3B B3 ? ? ? ? 0F 8E ? ? ? ? 8B 03 C7 44 24 08 ? ? ? ? 89 */

				"windows"	"\x74\x2A\x8B\x55\x2A\x8B\x06\x8B\x7A\x2A\x8B\x50"
				/*74 ? 8B 55 ? 8B 06 8B 7A ? 8B 50 */
			}

			/* Not an actual function,
				This rejects players when there are all full human players

				jl just before string "Human player limit reached (%d/%d)"

				deprecated on linux: This function checks GetMaxHumanPlayers
					on linux, so patching this to an unconditional jump
					removes a check on maxplayers.
			*/
			"HumanPlayerLimitReached"
			{
				"library"	"server"
				// "linux"		"\x7E\x2A\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x2A"
				/* 7E ? 8B ? ? 89 ? ? ? 8B ? ? 89 ? ? ? 8B ? ? 89 ? ? ? 8B ? ? 89 ? ? ? 8B ? ? 89 ? ? ? 8B */
				"windows" "\x7C\x2A\x8B\x4D\x2A\x8B\x55\x2A\x50\x57\x68"
				/* 7C ? 8B 4D ? 8B 55 ? 50 57 68 */
			}
			// ====================================================================================================



			// ====================================================================================================
			// UNUSED SIGNATURES
			// ====================================================================================================
			/*
			 * CDirectorScavengeMode::OnBeginRoundSetupTime
			 * used to reset the setup timer during scavenge mode
			 * has one of five references to string "ready_countdown"
			 */
			"CDirectorScavengeMode_OnBeginRoundSetupTime"
			{
				"library"	"server"
				"linux"		"@_ZN21CDirectorScavengeMode21OnBeginRoundSetupTimeEv"
				"windows"	"\x55\x8B\xEC\x83\xEC\x10\x56\x8B\xF1\xE8\x2A\x2A\x2A\x2A\x84\xC0\x74\x2A\xF3"
				/* 55 8B EC 83 EC 10 56 8B F1 E8 ? ? ? ? 84 C0 74 ? F3 */
			}

			/* CTerrorGameRules::ResetRoundNumber
			 * used to reset the round number during scavenge mode
 			 * Search for unique string "singlechapter"
			 * -> has two xref from same function, CTerrorGameRules::IsSingleChapterMode()
			 * -> has two xref, one is CRestartGameIssue::ExecuteCommand() (exclude the other, CServerGameDLL::ServerHibernationUpdate(), which has string "FCVAR_NEVER_AS_STRING")
			 * -> calls CTerrorGameRules::GetMissionFirstMap (TODO more detail on where this is)
			 * -> xref from CDirector::Rematch
			 * -> CTerrorGameRules::ResetRoundNumber is called right before CTerrorGameRules::IsVersusMode
			 */
			"CTerrorGameRules_ResetRoundNumber"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules16ResetRoundNumberEv"
				"windows"	"\x56\x8B\xF1\x83\xBE\x2A\x2A\x2A\x2A\x00\x74\x2A\xE8\x2A\x2A\x2A\x2A\xC7\x86\x2A\x2A\x2A\x2A\x00\x00\x00\x00\x5E\xC3"
				/* 56 8B F1 83 BE ? ? ? ? 00 74 ? E8 ? ? ? ? C7 86 ? ? ? ? 00 00 00 00 5E C3 */
			}

			/* CTerrorGameRules::SetRoundEndTime(float)
			 * used to freeze the scavenge game clock
			 * start with unique string "scavenge_round_halftime" in function CDirectorScavengeMode::EndScavengeRound
			 * -> first call in CDirectorScavengeMode::EndScavengeRound
 			 */
			"CTerrorGameRules_SetRoundEndTime"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules15SetRoundEndTimeEf"
				"windows"	"\x55\x8B\xEC\x56\x8B\xF1\xF3\x0F\x10\x86\x2A\x2A\x2A\x2A\x0F\x2E\x45\x08\x9F\x57"
				/* 55 8B EC 56 8B F1 F3 0F 10 86 ? ? ? ? 0F 2E 45 08 9F 57 */
			}

			/*
			 * CDirector::IsFinale(void)const
			 */
			"IsFinale"
			{
				"library"	"server"
				"linux"		"@_ZNK9CDirector8IsFinaleEv"
				"windows"	"\x8B\x81\x2A\x2A\x2A\x2A\x33\xC9\x83\x38\x2A\x0F\x95\xC0\xC3"
				/* 8B 81 ? ? ? ? 33 C9 83 38 ? 0F 95 C0 C3 */
			}

			/*
			* CDirectorVersusMode::OnVersusRoundStarted()
			* Unused? Nothing in source accesses this signature
			* Last call in CDirector::OnFirstSurvivorLeftSafeArea()
			* Also has string "versus_round_start"
			*/
			"OnVersusRoundStarted"
			{
				"library" 	"server"
				"linux" 	"@_ZN19CDirectorVersusMode20OnVersusRoundStartedEv"
				"windows" 	"\x8B\x0D\x2A\x2A\x2A\x2A\x85\xC9\x74\x2A\xA1\x2A\x2A\x2A\x2A\xD9\x2A\x2A\x51\xD9\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B"
				/* 8B 0D ? ? ? ? 85 C9 74 ? A1 ? ? ? ? D9 ? ? 51 D9 ? ? E8 ? ? ? ? 8B */
			}

			/* CTerrorPlayer::RoundRespawn */
			"CTerrorPlayer::RoundRespawn"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer12RoundRespawnEv"
				"windows"	"\x56\x8B\xF1\xE8\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x84\xC0\x75"
				/* 56 8B F1 E8 ? ? ? ? E8 ? ? ? ? 84 C0 75	*/
			}

			/*
			 * GetDifficulty(void)
			 */
			"GetDifficulty"
			{
				"library"	"server"
				"linux"		"@_Z13GetDifficultyv"
				"windows" 	"\xA1\x2A\x48\x7A\x10\xC3"
				/* A1 ? 48 7A 10 C3 */
			}

			/*
			 *	CTerrorGameRules::GetMissionCurrentMap(KeyValues **)
			 *
			 * - Look for string "chapter" (unique on Windows only) in CDirector:OnMapLoaded.
			 * - Function called right before that with 0 as arg.
			 * NOTE/WARNING: This function is incredibly non-unique!!!! Replace with a native implementation!!
			 */
			"GetMissionCurrentMap"
			{
				"library"	"server"
				"linux" 	"@_ZN16CTerrorGameRules20GetMissionCurrentMapEPP9KeyValues"
				"windows"	"\x55\x8B\xEC\x56\x57\x8B\x7D\x08\x85\xFF\x74\x06\xC7\x07\x00\x00\x00\x00\x8B\x0D\x2A\x2A\x2A\x2A\x8B\x01\x8B\x50\x28\xFF\xD2\x8B\x10\x8B\xC8\x8B\x42\x04\x6A\x00\xFF\xD0\x8B\xF0\x85\xF6\x75\x04\x5F\x5E\x5D\xC3\x8B\x0D\x2A\x2A\x2A\x2A\x8B\x11\x8B\x42\x08\x57\x56\xFF\xD0\x8B"
				/*
				 * 68 byte signature. Fuck me.
				 * 55 8B EC 56 57 8B 7D 08 85 FF 74 06 C7 07 00 00 00 00 8B 0D ? ? ? ? 8B 01 8B 50 28 FF D2 8B 10 8B C8 8B 42 04 6A 00 FF D0 8B F0 85 F6 75 04 5F 5E 5D C3 8B 0D ? ? ? ? 8B 11 8B 42 08 57 56 FF D0 8B
				 */
			}

			/*
			* CBasePlayer::WaterMove(void)
			*/
			"CBasePlayer::WaterMove"
			{
				"library"	"server"
				"linux"		"@_ZN11CBasePlayer9WaterMoveEv"
				"windows"	"\x55\x8B\xEC\x83\xEC\x60\x56\x8B\xF1\x80\xBE\x72\x01\x00\x00\x08"
				/* 55 8B EC 83 EC 60 56 8B F1 80 BE 72 01 00 00 08 */
			}

			/*
			 * InfectedShoved::OnShoved(InfectedShoved *this, Infected *, CBaseEntity *)
			 * Have to hook each common infected to enable. Feature not planned.
			 */
			"InfectedShoved::OnShoved"
			{
				"library"	"server"
				"linux"		"@_ZN14InfectedShoved8OnShovedEP8InfectedP11CBaseEntity"
				"windows"	""
				/* */
			}

			/*
			* CBaseServer::GetClient(int)
			*/
			"CBaseClient_GetNetworkIDString"
			{
				"library"	"engine"
				"linux"		"@_ZNK11CBaseClient18GetNetworkIDStringEv"
				"windows"	"\x55\x8B\x2A\x83\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x56\x8B\x2A\x8B\x2A\x8B\x2A\x2A\x2A\x2A\x2A\xFF\x2A\x84"
				/* 55 8B ? 83 ? ? A1 ? ? ? ? 33 ? 89 ? ? 56 8B ? 8B ? 8B ? ? ? ? ? FF ? 84 */
				/* Search: "STEAM_%u:%u:%u" - called by target that contains "BOT". */
			}
		}
	}
}